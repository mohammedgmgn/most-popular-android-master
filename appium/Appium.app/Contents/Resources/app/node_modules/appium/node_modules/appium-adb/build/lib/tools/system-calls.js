"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DEFAULT_ADB_EXEC_TIMEOUT", {
  enumerable: true,
  get: function () {
    return _helpers.DEFAULT_ADB_EXEC_TIMEOUT;
  }
});
exports.default = void 0;

require("source-map-support/register");

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("../logger.js"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumSupport = require("appium-support");

var _helpers = require("../helpers");

var _teen_process = require("teen_process");

var _asyncbox = require("asyncbox");

var _lodash = _interopRequireDefault(require("lodash"));

var _shellQuote = require("shell-quote");

let systemCallMethods = {};
const DEFAULT_ADB_REBOOT_RETRIES = 90;
const LINKER_WARNING_REGEXP = /^WARNING: linker.+$/m;
const PROTOCOL_FAULT_ERROR_REGEXP = new RegExp('protocol fault \\(no status\\)', 'i');
const DEVICE_NOT_FOUND_ERROR_REGEXP = new RegExp(`error: device ('.+' )?not found`, 'i');
const DEVICE_CONNECTING_ERROR_REGEXP = new RegExp('error: device still connecting', 'i');
const CERTS_ROOT = '/system/etc/security/cacerts';
systemCallMethods.getSdkBinaryPath = _lodash.default.memoize(async function getSdkBinaryPath(binaryName) {
  _logger.default.info(`Checking whether ${binaryName} is present`);

  if (this.sdkRoot) {
    return await this.getBinaryFromSdkRoot(binaryName);
  }

  _logger.default.warn(`The ANDROID_HOME environment variable is not set to the Android SDK ` + `root directory path. ANDROID_HOME is required for compatibility ` + `with SDK 23+. Checking along PATH for ${binaryName}.`);

  return await this.getBinaryFromPath(binaryName);
});
systemCallMethods.getCommandForOS = _lodash.default.memoize(function getCommandForOS() {
  return _appiumSupport.system.isWindows() ? 'where' : 'which';
});
systemCallMethods.getBinaryNameForOS = _lodash.default.memoize(function getBinaryNameForOS(binaryName) {
  if (!_appiumSupport.system.isWindows()) {
    return binaryName;
  }

  if (['android', 'apksigner', 'apkanalyzer'].indexOf(binaryName) >= 0 && !binaryName.toLowerCase().endsWith('.bat')) {
    return `${binaryName}.bat`;
  }

  if (!binaryName.toLowerCase().endsWith('.exe')) {
    return `${binaryName}.exe`;
  }

  return binaryName;
});
systemCallMethods.getBinaryFromSdkRoot = _lodash.default.memoize(async function getBinaryFromSdkRoot(binaryName) {
  let binaryLoc = null;
  binaryName = this.getBinaryNameForOS(binaryName);
  let binaryLocs = [_path.default.resolve(this.sdkRoot, 'platform-tools', binaryName), _path.default.resolve(this.sdkRoot, 'emulator', binaryName), _path.default.resolve(this.sdkRoot, 'tools', binaryName), _path.default.resolve(this.sdkRoot, 'tools', 'bin', binaryName)];

  _lodash.default.forEach((await (0, _helpers.getBuildToolsDirs)(this.sdkRoot)), dir => binaryLocs.push(_path.default.resolve(dir, binaryName)));

  for (let loc of binaryLocs) {
    if (await _appiumSupport.fs.exists(loc)) {
      binaryLoc = loc;
      break;
    }
  }

  if (_lodash.default.isNull(binaryLoc)) {
    throw new Error(`Could not find ${binaryName} in ${binaryLocs}. ` + `Do you have the Android SDK installed at '${this.sdkRoot}'?`);
  }

  binaryLoc = binaryLoc.trim();

  _logger.default.info(`Using ${binaryName} from ${binaryLoc}`);

  return binaryLoc;
});

systemCallMethods.getBinaryFromPath = async function getBinaryFromPath(binaryName) {
  let binaryLoc = null;
  let cmd = this.getCommandForOS();

  try {
    let {
      stdout
    } = await (0, _teen_process.exec)(cmd, [binaryName]);

    _logger.default.info(`Using ${binaryName} from ${stdout}`);

    binaryLoc = stdout.trim();
    return binaryLoc;
  } catch (e) {
    throw new Error(`Could not find ${binaryName} Please set the ANDROID_HOME ` + `environment variable with the Android SDK root directory path.`);
  }
};

systemCallMethods.getConnectedDevices = async function getConnectedDevices() {
  _logger.default.debug('Getting connected devices...');

  try {
    let {
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, this.executable.defaultArgs.concat(['devices']));
    let startingIndex = stdout.indexOf('List of devices');

    if (startingIndex === -1) {
      throw new Error(`Unexpected output while trying to get devices. output was: ${stdout}`);
    }

    stdout = stdout.slice(startingIndex);
    let devices = [];

    for (let line of stdout.split('\n')) {
      if (line.trim() !== '' && line.indexOf('List of devices') === -1 && line.indexOf('adb server') === -1 && line.indexOf('* daemon') === -1 && line.indexOf('offline') === -1) {
        let lineInfo = line.split('\t');
        devices.push({
          udid: lineInfo[0],
          state: lineInfo[1]
        });
      }
    }

    _logger.default.debug(`${devices.length} device(s) connected`);

    return devices;
  } catch (e) {
    throw new Error(`Error while getting connected devices. Original error: ${e.message}`);
  }
};

systemCallMethods.getDevicesWithRetry = async function getDevicesWithRetry(timeoutMs = 20000) {
  let start = Date.now();

  _logger.default.debug('Trying to find a connected android device');

  let getDevices = async () => {
    if (Date.now() - start > timeoutMs) {
      throw new Error('Could not find a connected Android device.');
    }

    try {
      let devices = await this.getConnectedDevices();

      if (devices.length < 1) {
        _logger.default.debug('Could not find devices, restarting adb server...');

        await this.restartAdb();
        await (0, _asyncbox.sleep)(200);
        return await getDevices();
      }

      return devices;
    } catch (e) {
      _logger.default.debug('Could not find devices, restarting adb server...');

      await this.restartAdb();
      await (0, _asyncbox.sleep)(200);
      return await getDevices();
    }
  };

  return await getDevices();
};

systemCallMethods.restartAdb = async function restartAdb() {
  if (this.suppressKillServer) {
    _logger.default.debug(`Not restarting abd since 'suppressKillServer' is on`);

    return;
  }

  _logger.default.debug('Restarting adb');

  try {
    await this.killServer();
  } catch (e) {
    _logger.default.error("Error killing ADB server, going to see if it's online anyway");
  }
};

systemCallMethods.killServer = async function killServer() {
  _logger.default.debug(`Killing adb server on port ${this.adbPort}`);

  await (0, _teen_process.exec)(this.executable.path, [...this.executable.defaultArgs, 'kill-server']);
};

systemCallMethods.resetTelnetAuthToken = _lodash.default.memoize(async function resetTelnetAuthToken() {
  const homeFolderPath = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

  if (!homeFolderPath) {
    _logger.default.warn(`Cannot find the path to user home folder. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  const dstPath = _path.default.resolve(homeFolderPath, '.emulator_console_auth_token');

  _logger.default.debug(`Overriding ${dstPath} with an empty string to avoid telnet authentication for emulator commands`);

  try {
    await _appiumSupport.fs.writeFile(dstPath, '');
  } catch (e) {
    _logger.default.warn(`Error ${e.message} while resetting the content of ${dstPath}. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  return true;
});

systemCallMethods.adbExecEmu = async function adbExecEmu(cmd) {
  await this.verifyEmulatorConnected();
  await this.resetTelnetAuthToken();
  await this.adbExec(['emu', ...cmd]);
};

systemCallMethods.adbExec = async function adbExec(cmd, opts = {}) {
  if (!cmd) {
    throw new Error('You need to pass in a command to adbExec()');
  }

  opts.timeout = opts.timeout || this.adbExecTimeout || _helpers.DEFAULT_ADB_EXEC_TIMEOUT;
  opts.timeoutCapName = opts.timeoutCapName || 'adbExecTimeout';
  cmd = _lodash.default.isArray(cmd) ? cmd : [cmd];
  let adbRetried = false;

  const execFunc = async () => {
    try {
      const args = this.executable.defaultArgs.concat(cmd);

      _logger.default.debug(`Running '${this.executable.path} ${(0, _shellQuote.quote)(args)}'`);

      let {
        stdout
      } = await (0, _teen_process.exec)(this.executable.path, args, opts);
      stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      return stdout;
    } catch (e) {
      const errText = `${e.message}, ${e.stdout}, ${e.stderr}`;
      const protocolFaultError = PROTOCOL_FAULT_ERROR_REGEXP.test(errText);
      const deviceNotFoundError = DEVICE_NOT_FOUND_ERROR_REGEXP.test(errText);
      const deviceConnectingError = DEVICE_CONNECTING_ERROR_REGEXP.test(errText);

      if (protocolFaultError || deviceNotFoundError || deviceConnectingError) {
        _logger.default.info(`Error sending command, reconnecting device and retrying: ${cmd}`);

        await (0, _asyncbox.sleep)(1000);
        await this.getDevicesWithRetry();

        if (adbRetried) {
          adbRetried = true;
          return await execFunc();
        }
      }

      if (e.code === 0 && e.stdout) {
        return e.stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      }

      if (_lodash.default.isNull(e.code)) {
        e.message = `Error executing adbExec. Original error: '${e.message}'. ` + `Try to increase the ${opts.timeout}ms adb execution timeout represented by '${opts.timeoutCapName}' capability`;
      } else {
        e.message = `Error executing adbExec. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`;
      }

      throw e;
    }
  };

  return await execFunc();
};

systemCallMethods.shell = async function shell(cmd, opts = {}) {
  const {
    privileged,
    keepPrivileged
  } = opts;
  let shouldRestoreUser = false;

  if (privileged) {
    try {
      shouldRestoreUser = !(await this.adbExec(['root'], opts)).includes('already running as root');
    } catch (err) {
      if (!err.message.includes('adbd cannot run as root')) {
        _logger.default.warn(`Cannot run adbd as root. Original error: ${err.message}`);
      }
    }
  }

  let didCommandFail = false;

  try {
    try {
      return await this.adbExec(_lodash.default.isArray(cmd) ? ['shell', ...cmd] : ['shell', cmd], opts);
    } catch (err) {
      didCommandFail = true;
      throw err;
    }
  } finally {
    if (privileged && shouldRestoreUser && (!keepPrivileged || didCommandFail)) {
      try {
        await this.adbExec(['unroot'], opts);
      } catch (err) {
        _logger.default.warn(`Cannot run adbd as non-root. Original error: ${err.message}`);
      }
    }
  }
};

systemCallMethods.createSubProcess = function createSubProcess(args = []) {
  args = this.executable.defaultArgs.concat(args);

  _logger.default.debug(`Creating ADB subprocess with args: ${JSON.stringify(args)}`);

  return new _teen_process.SubProcess(this.getAdbPath(), args);
};

systemCallMethods.getAdbServerPort = function getAdbServerPort() {
  return this.adbPort;
};

systemCallMethods.getEmulatorPort = async function getEmulatorPort() {
  _logger.default.debug('Getting running emulator port');

  if (this.emulatorPort !== null) {
    return this.emulatorPort;
  }

  try {
    let devices = await this.getConnectedDevices();
    let port = this.getPortFromEmulatorString(devices[0].udid);

    if (port) {
      return port;
    } else {
      throw new Error(`Emulator port not found`);
    }
  } catch (e) {
    throw new Error(`No devices connected. Original error: ${e.message}`);
  }
};

systemCallMethods.getPortFromEmulatorString = function getPortFromEmulatorString(emStr) {
  let portPattern = /emulator-(\d+)/;

  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }

  return false;
};

systemCallMethods.getConnectedEmulators = async function getConnectedEmulators() {
  _logger.default.debug('Getting connected emulators');

  try {
    let devices = await this.getConnectedDevices();
    let emulators = [];

    for (let device of devices) {
      let port = this.getPortFromEmulatorString(device.udid);

      if (port) {
        device.port = port;
        emulators.push(device);
      }
    }

    _logger.default.debug(`${emulators.length} emulator(s) connected`);

    return emulators;
  } catch (e) {
    throw new Error(`Error getting emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.setEmulatorPort = function setEmulatorPort(emPort) {
  this.emulatorPort = emPort;
};

systemCallMethods.setDeviceId = function setDeviceId(deviceId) {
  _logger.default.debug(`Setting device id to ${deviceId}`);

  this.curDeviceId = deviceId;
  let argsHasDevice = this.executable.defaultArgs.indexOf('-s');

  if (argsHasDevice !== -1) {
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }

  this.executable.defaultArgs.push('-s', deviceId);
};

systemCallMethods.setDevice = function setDevice(deviceObj) {
  let deviceId = deviceObj.udid;
  let emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};

systemCallMethods.getRunningAVD = async function getRunningAVD(avdName) {
  _logger.default.debug(`Trying to find ${avdName} emulator`);

  try {
    let emulators = await this.getConnectedEmulators();

    for (let emulator of emulators) {
      this.setEmulatorPort(emulator.port);
      let runningAVDName = await this.sendTelnetCommand('avd name');

      if (avdName === runningAVDName) {
        _logger.default.debug(`Found emulator ${avdName} in port ${emulator.port}`);

        this.setDeviceId(emulator.udid);
        return emulator;
      }
    }

    _logger.default.debug(`Emulator ${avdName} not running`);

    return null;
  } catch (e) {
    throw new Error(`Error getting AVD. Original error: ${e.message}`);
  }
};

systemCallMethods.getRunningAVDWithRetry = async function getRunningAVDWithRetry(avdName, timeoutMs = 20000) {
  let runningAvd;

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        runningAvd = await this.getRunningAVD(avdName.replace('@', ''));
        return runningAvd;
      } catch (e) {
        _logger.default.debug(e.message);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 1000
    });
  } catch (e) {
    throw new Error(`Error getting AVD with retry. Original error: ${e.message}`);
  }

  return runningAvd;
};

systemCallMethods.killAllEmulators = async function killAllEmulators() {
  let cmd, args;

  if (_appiumSupport.system.isWindows()) {
    cmd = 'TASKKILL';
    args = ['TASKKILL', '/IM', 'emulator.exe'];
  } else {
    cmd = '/usr/bin/killall';
    args = ['-m', 'emulator*'];
  }

  try {
    await (0, _teen_process.exec)(cmd, args);
  } catch (e) {
    throw new Error(`Error killing emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.killEmulator = async function killEmulator(avdName = null, timeout = 60000) {
  if (_appiumSupport.util.hasValue(avdName)) {
    _logger.default.debug(`Killing avd '${avdName}'`);

    const device = await this.getRunningAVD(avdName);

    if (!device) {
      _logger.default.info(`No avd with name '${avdName}' running. Skipping kill step.`);

      return false;
    }
  } else {
    _logger.default.debug(`Killing avd with id '${this.curDeviceId}'`);

    if (!(await this.isEmulatorConnected())) {
      _logger.default.debug(`Emulator with id '${this.curDeviceId}' not connected. Skipping kill step`);

      return false;
    }
  }

  await this.adbExec(['emu', 'kill']);

  _logger.default.debug(`Waiting up to ${timeout}ms until the emulator '${avdName ? avdName : this.curDeviceId}' is killed`);

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        return _appiumSupport.util.hasValue(avdName) ? !(await this.getRunningAVD(avdName)) : !(await this.isEmulatorConnected());
      } catch (ign) {}

      return false;
    }, {
      waitMs: timeout,
      intervalMs: 2000
    });
  } catch (e) {
    throw new Error(`The emulator '${avdName ? avdName : this.curDeviceId}' is still running after being killed ${timeout}ms ago`);
  }

  _logger.default.info(`Successfully killed the '${avdName ? avdName : this.curDeviceId}' emulator`);

  return true;
};

systemCallMethods.launchAVD = async function launchAVD(avdName, avdArgs, language, country, avdLaunchTimeout = 60000, avdReadyTimeout = 60000, retryTimes = 1) {
  _logger.default.debug(`Launching Emulator with AVD ${avdName}, launchTimeout ` + `${avdLaunchTimeout}ms and readyTimeout ${avdReadyTimeout}ms`);

  let emulatorBinaryPath = await this.getSdkBinaryPath('emulator');

  if (avdName[0] === '@') {
    avdName = avdName.substr(1);
  }

  await this.checkAvdExist(avdName);
  let launchArgs = ['-avd', avdName];

  if (_lodash.default.isString(language)) {
    _logger.default.debug(`Setting Android Device Language to ${language}`);

    launchArgs.push('-prop', `persist.sys.language=${language.toLowerCase()}`);
  }

  if (_lodash.default.isString(country)) {
    _logger.default.debug(`Setting Android Device Country to ${country}`);

    launchArgs.push('-prop', `persist.sys.country=${country.toUpperCase()}`);
  }

  let locale;

  if (_lodash.default.isString(language) && _lodash.default.isString(country)) {
    locale = language.toLowerCase() + '-' + country.toUpperCase();
  } else if (_lodash.default.isString(language)) {
    locale = language.toLowerCase();
  } else if (_lodash.default.isString(country)) {
    locale = country;
  }

  if (_lodash.default.isString(locale)) {
    _logger.default.debug(`Setting Android Device Locale to ${locale}`);

    launchArgs.push('-prop', `persist.sys.locale=${locale}`);
  }

  if (!_lodash.default.isEmpty(avdArgs)) {
    launchArgs.push(...(_lodash.default.isArray(avdArgs) ? avdArgs : avdArgs.split(' ')));
  }

  _logger.default.debug(`Running '${emulatorBinaryPath}' with args: ${JSON.stringify(launchArgs)}`);

  let proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs);
  await proc.start(0);
  proc.on('output', (stdout, stderr) => {
    for (let line of (stdout || stderr || '').split('\n').filter(Boolean)) {
      _logger.default.info(`[AVD OUTPUT] ${line}`);
    }
  });
  proc.on('die', (code, signal) => {
    _logger.default.warn(`Emulator avd ${avdName} exited with code ${code}${signal ? `, signal ${signal}` : ''}`);
  });
  await (0, _asyncbox.retry)(retryTimes, async () => await this.getRunningAVDWithRetry(avdName, avdLaunchTimeout));
  await this.waitForEmulatorReady(avdReadyTimeout);
  return proc;
};

systemCallMethods.getAdbVersion = _lodash.default.memoize(async function getAdbVersion() {
  try {
    let adbVersion = (await this.adbExec('version')).replace(/Android\sDebug\sBridge\sversion\s([\d.]*)[\s\w-]*/, '$1');
    let parts = adbVersion.split('.');
    return {
      versionString: adbVersion,
      versionFloat: parseFloat(adbVersion),
      major: parseInt(parts[0], 10),
      minor: parseInt(parts[1], 10),
      patch: parts[2] ? parseInt(parts[2], 10) : undefined
    };
  } catch (e) {
    throw new Error(`Error getting adb version. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
  }
});

systemCallMethods.checkAvdExist = async function checkAvdExist(avdName) {
  let cmd, result;

  try {
    cmd = await this.getSdkBinaryPath('emulator');
    result = await (0, _teen_process.exec)(cmd, ['-list-avds']);
  } catch (e) {
    let unknownOptionError = new RegExp('unknown option: -list-avds', 'i').test(e.stderr);

    if (!unknownOptionError) {
      throw new Error(`Error executing checkAvdExist. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
    }

    const sdkVersion = await (0, _helpers.getSdkToolsVersion)();
    let binaryName = 'android';

    if (sdkVersion) {
      if (sdkVersion.major >= 25) {
        binaryName = 'avdmanager';
      }
    } else {
      _logger.default.warn(`Defaulting binary name to '${binaryName}', because SDK version cannot be parsed`);
    }

    cmd = await this.getSdkBinaryPath(binaryName);
    result = await (0, _teen_process.exec)(cmd, ['list', 'avd', '-c']);
  }

  if (result.stdout.indexOf(avdName) === -1) {
    let existings = `(${result.stdout.trim().replace(/[\n]/g, '), (')})`;
    throw new Error(`Avd '${avdName}' is not available. please select your avd name from one of these: '${existings}'`);
  }
};

systemCallMethods.waitForEmulatorReady = async function waitForEmulatorReady(timeoutMs = 20000) {
  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        if (!(await this.shell(['getprop', 'init.svc.bootanim'])).includes('stopped')) {
          return false;
        }

        return /\d+\[\w+\]/.test((await this.shell(['pm', 'get-install-location'])));
      } catch (err) {
        _logger.default.debug(`Waiting for emulator startup. Intermediate error: ${err.message}`);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 3000
    });
  } catch (e) {
    throw new Error(`Emulator is not ready within ${timeoutMs}ms`);
  }
};

systemCallMethods.waitForDevice = async function waitForDevice(appDeviceReadyTimeout = 30) {
  this.appDeviceReadyTimeout = appDeviceReadyTimeout;
  const retries = 3;
  const timeout = parseInt(this.appDeviceReadyTimeout, 10) / retries * 1000;
  await (0, _asyncbox.retry)(retries, async () => {
    try {
      await this.adbExec('wait-for-device', {
        timeout
      });
      await this.ping();
    } catch (e) {
      await this.restartAdb();
      await this.getConnectedDevices();
      throw new Error(`Error waiting for the device to be available. Original error: '${e.message}'`);
    }
  });
};

systemCallMethods.reboot = async function reboot(retries = DEFAULT_ADB_REBOOT_RETRIES) {
  await this.shell(['stop'], {
    privileged: true
  });
  await _bluebird.default.delay(2000);
  await this.setDeviceProperty('sys.boot_completed', 0);
  await this.shell(['start'], {
    privileged: true
  });
  const started = process.hrtime();
  await (0, _asyncbox.retryInterval)(retries, 1000, async () => {
    if ((await this.getDeviceProperty('sys.boot_completed')) === '1') {
      return;
    }

    const msg = `Reboot is not completed after ${process.hrtime(started)[0]}s`;

    _logger.default.debug(msg);

    throw new Error(msg);
  });
};

systemCallMethods.root = async function root() {
  try {
    let {
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, ['root']);

    if (stdout && stdout.indexOf('adbd cannot run as root') !== -1) {
      throw new Error(stdout.trim());
    }

    return true;
  } catch (err) {
    _logger.default.warn(`Unable to root adb daemon: '${err.message}'. Continuing`);

    return false;
  }
};

systemCallMethods.unroot = async function unroot() {
  try {
    await (0, _teen_process.exec)(this.executable.path, ['unroot']);
    return true;
  } catch (err) {
    _logger.default.warn(`Unable to unroot adb daemon: '${err.message}'. Continuing`);

    return false;
  }
};

systemCallMethods.isRoot = async function isRoot() {
  return (await this.shell(['whoami'])).trim() === 'root';
};

systemCallMethods.fileExists = async function fileExists(remotePath) {
  let files = await this.ls(remotePath);
  return files.length > 0;
};

systemCallMethods.ls = async function ls(remotePath, opts = []) {
  try {
    let args = ['ls', ...opts, remotePath];
    let stdout = await this.shell(args);
    let lines = stdout.split('\n');
    return lines.map(l => l.trim()).filter(Boolean).filter(l => l.indexOf('No such file') === -1);
  } catch (err) {
    if (err.message.indexOf('No such file or directory') === -1) {
      throw err;
    }

    return [];
  }
};

systemCallMethods.fileSize = async function fileSize(remotePath) {
  try {
    const files = await this.ls(remotePath, ['-la']);

    if (files.length !== 1) {
      throw new Error(`Remote path is not a file`);
    }

    const match = /[rwxsStT\-+]{10}[\s\d]*\s[^\s]+\s+[^\s]+\s+(\d+)/.exec(files[0]);

    if (!match || _lodash.default.isNaN(parseInt(match[1], 10))) {
      throw new Error(`Unable to parse size from list output: '${files[0]}'`);
    }

    return parseInt(match[1], 10);
  } catch (err) {
    throw new Error(`Unable to get file size for '${remotePath}': ${err.message}`);
  }
};

systemCallMethods.installMitmCertificate = async function installMitmCertificate(cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _appiumSupport.tempDir.openDir();

  try {
    const srcCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _appiumSupport.fs.writeFile(srcCert, cert);
    let {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', srcCert]);
    const certHash = stdout.trim();

    _logger.default.debug(`Got certificate hash: ${certHash}`);

    _logger.default.debug('Preparing certificate content');

    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert], {
      isBuffer: true
    }));
    let dstCertContent = stdout;
    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert, '-text', '-fingerprint', '-noout'], {
      isBuffer: true
    }));
    dstCertContent = Buffer.concat([dstCertContent, stdout]);

    const dstCert = _path.default.resolve(tmpRoot, `${certHash}.0`);

    await _appiumSupport.fs.writeFile(dstCert, dstCertContent);

    _logger.default.debug('Remounting /system in rw mode');

    await (0, _asyncbox.retryInterval)(5, 2000, async () => await this.adbExec(['remount']));

    _logger.default.debug(`Uploading the generated certificate from '${dstCert}' to '${CERTS_ROOT}'`);

    await this.push(dstCert, CERTS_ROOT);

    _logger.default.debug('Remounting /system to confirm changes');

    await this.adbExec(['remount']);
  } catch (err) {
    throw new Error(`Cannot inject the custom certificate. ` + `Is the certificate properly encoded into base64-string? ` + `Do you have root permissions on the device? ` + `Original error: ${err.message}`);
  } finally {
    await _appiumSupport.fs.rimraf(tmpRoot);
  }
};

systemCallMethods.isMitmCertificateInstalled = async function isMitmCertificateInstalled(cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _appiumSupport.tempDir.openDir();
  let certHash;

  try {
    const tmpCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _appiumSupport.fs.writeFile(tmpCert, cert);
    const {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', tmpCert]);
    certHash = stdout.trim();
  } catch (err) {
    throw new Error(`Cannot retrieve the certificate hash. ` + `Is the certificate properly encoded into base64-string? ` + `Original error: ${err.message}`);
  } finally {
    await _appiumSupport.fs.rimraf(tmpRoot);
  }

  const dstPath = _path.default.posix.resolve(CERTS_ROOT, `${certHash}.0`);

  _logger.default.debug(`Checking if the certificate is already installed at '${dstPath}'`);

  return await this.fileExists(dstPath);
};

var _default = systemCallMethods;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiXSwibmFtZXMiOlsic3lzdGVtQ2FsbE1ldGhvZHMiLCJERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyIsIkxJTktFUl9XQVJOSU5HX1JFR0VYUCIsIlBST1RPQ09MX0ZBVUxUX0VSUk9SX1JFR0VYUCIsIlJlZ0V4cCIsIkRFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQIiwiREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQIiwiQ0VSVFNfUk9PVCIsImdldFNka0JpbmFyeVBhdGgiLCJfIiwibWVtb2l6ZSIsImJpbmFyeU5hbWUiLCJsb2ciLCJpbmZvIiwic2RrUm9vdCIsImdldEJpbmFyeUZyb21TZGtSb290Iiwid2FybiIsImdldEJpbmFyeUZyb21QYXRoIiwiZ2V0Q29tbWFuZEZvck9TIiwic3lzdGVtIiwiaXNXaW5kb3dzIiwiZ2V0QmluYXJ5TmFtZUZvck9TIiwiaW5kZXhPZiIsInRvTG93ZXJDYXNlIiwiZW5kc1dpdGgiLCJiaW5hcnlMb2MiLCJiaW5hcnlMb2NzIiwicGF0aCIsInJlc29sdmUiLCJmb3JFYWNoIiwiZGlyIiwicHVzaCIsImxvYyIsImZzIiwiZXhpc3RzIiwiaXNOdWxsIiwiRXJyb3IiLCJ0cmltIiwiY21kIiwic3Rkb3V0IiwiZSIsImdldENvbm5lY3RlZERldmljZXMiLCJkZWJ1ZyIsImV4ZWN1dGFibGUiLCJkZWZhdWx0QXJncyIsImNvbmNhdCIsInN0YXJ0aW5nSW5kZXgiLCJzbGljZSIsImRldmljZXMiLCJsaW5lIiwic3BsaXQiLCJsaW5lSW5mbyIsInVkaWQiLCJzdGF0ZSIsImxlbmd0aCIsIm1lc3NhZ2UiLCJnZXREZXZpY2VzV2l0aFJldHJ5IiwidGltZW91dE1zIiwic3RhcnQiLCJEYXRlIiwibm93IiwiZ2V0RGV2aWNlcyIsInJlc3RhcnRBZGIiLCJzdXBwcmVzc0tpbGxTZXJ2ZXIiLCJraWxsU2VydmVyIiwiZXJyb3IiLCJhZGJQb3J0IiwicmVzZXRUZWxuZXRBdXRoVG9rZW4iLCJob21lRm9sZGVyUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJwbGF0Zm9ybSIsImRzdFBhdGgiLCJ3cml0ZUZpbGUiLCJhZGJFeGVjRW11IiwidmVyaWZ5RW11bGF0b3JDb25uZWN0ZWQiLCJhZGJFeGVjIiwib3B0cyIsInRpbWVvdXQiLCJhZGJFeGVjVGltZW91dCIsIkRFRkFVTFRfQURCX0VYRUNfVElNRU9VVCIsInRpbWVvdXRDYXBOYW1lIiwiaXNBcnJheSIsImFkYlJldHJpZWQiLCJleGVjRnVuYyIsImFyZ3MiLCJyZXBsYWNlIiwiZXJyVGV4dCIsInN0ZGVyciIsInByb3RvY29sRmF1bHRFcnJvciIsInRlc3QiLCJkZXZpY2VOb3RGb3VuZEVycm9yIiwiZGV2aWNlQ29ubmVjdGluZ0Vycm9yIiwiY29kZSIsInNoZWxsIiwicHJpdmlsZWdlZCIsImtlZXBQcml2aWxlZ2VkIiwic2hvdWxkUmVzdG9yZVVzZXIiLCJpbmNsdWRlcyIsImVyciIsImRpZENvbW1hbmRGYWlsIiwiY3JlYXRlU3ViUHJvY2VzcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJTdWJQcm9jZXNzIiwiZ2V0QWRiUGF0aCIsImdldEFkYlNlcnZlclBvcnQiLCJnZXRFbXVsYXRvclBvcnQiLCJlbXVsYXRvclBvcnQiLCJwb3J0IiwiZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyIsImVtU3RyIiwicG9ydFBhdHRlcm4iLCJwYXJzZUludCIsImV4ZWMiLCJnZXRDb25uZWN0ZWRFbXVsYXRvcnMiLCJlbXVsYXRvcnMiLCJkZXZpY2UiLCJzZXRFbXVsYXRvclBvcnQiLCJlbVBvcnQiLCJzZXREZXZpY2VJZCIsImRldmljZUlkIiwiY3VyRGV2aWNlSWQiLCJhcmdzSGFzRGV2aWNlIiwic3BsaWNlIiwic2V0RGV2aWNlIiwiZGV2aWNlT2JqIiwiZ2V0UnVubmluZ0FWRCIsImF2ZE5hbWUiLCJlbXVsYXRvciIsInJ1bm5pbmdBVkROYW1lIiwic2VuZFRlbG5ldENvbW1hbmQiLCJnZXRSdW5uaW5nQVZEV2l0aFJldHJ5IiwicnVubmluZ0F2ZCIsIndhaXRNcyIsImludGVydmFsTXMiLCJraWxsQWxsRW11bGF0b3JzIiwia2lsbEVtdWxhdG9yIiwidXRpbCIsImhhc1ZhbHVlIiwiaXNFbXVsYXRvckNvbm5lY3RlZCIsImlnbiIsImxhdW5jaEFWRCIsImF2ZEFyZ3MiLCJsYW5ndWFnZSIsImNvdW50cnkiLCJhdmRMYXVuY2hUaW1lb3V0IiwiYXZkUmVhZHlUaW1lb3V0IiwicmV0cnlUaW1lcyIsImVtdWxhdG9yQmluYXJ5UGF0aCIsInN1YnN0ciIsImNoZWNrQXZkRXhpc3QiLCJsYXVuY2hBcmdzIiwiaXNTdHJpbmciLCJ0b1VwcGVyQ2FzZSIsImxvY2FsZSIsImlzRW1wdHkiLCJwcm9jIiwib24iLCJmaWx0ZXIiLCJCb29sZWFuIiwic2lnbmFsIiwid2FpdEZvckVtdWxhdG9yUmVhZHkiLCJnZXRBZGJWZXJzaW9uIiwiYWRiVmVyc2lvbiIsInBhcnRzIiwidmVyc2lvblN0cmluZyIsInZlcnNpb25GbG9hdCIsInBhcnNlRmxvYXQiLCJtYWpvciIsIm1pbm9yIiwicGF0Y2giLCJ1bmRlZmluZWQiLCJyZXN1bHQiLCJ1bmtub3duT3B0aW9uRXJyb3IiLCJzZGtWZXJzaW9uIiwiZXhpc3RpbmdzIiwid2FpdEZvckRldmljZSIsImFwcERldmljZVJlYWR5VGltZW91dCIsInJldHJpZXMiLCJwaW5nIiwicmVib290IiwiQiIsImRlbGF5Iiwic2V0RGV2aWNlUHJvcGVydHkiLCJzdGFydGVkIiwiaHJ0aW1lIiwiZ2V0RGV2aWNlUHJvcGVydHkiLCJtc2ciLCJyb290IiwidW5yb290IiwiaXNSb290IiwiZmlsZUV4aXN0cyIsInJlbW90ZVBhdGgiLCJmaWxlcyIsImxzIiwibGluZXMiLCJtYXAiLCJsIiwiZmlsZVNpemUiLCJtYXRjaCIsImlzTmFOIiwiaW5zdGFsbE1pdG1DZXJ0aWZpY2F0ZSIsImNlcnQiLCJvcGVuU3NsIiwiaXNCdWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwidG1wUm9vdCIsInRlbXBEaXIiLCJvcGVuRGlyIiwic3JjQ2VydCIsImNlcnRIYXNoIiwiZHN0Q2VydENvbnRlbnQiLCJkc3RDZXJ0IiwicmltcmFmIiwiaXNNaXRtQ2VydGlmaWNhdGVJbnN0YWxsZWQiLCJ0bXBDZXJ0IiwicG9zaXgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBS0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0EsSUFBSUEsaUJBQWlCLEdBQUcsRUFBeEI7QUFFQSxNQUFNQywwQkFBMEIsR0FBRyxFQUFuQztBQUVBLE1BQU1DLHFCQUFxQixHQUFHLHNCQUE5QjtBQUNBLE1BQU1DLDJCQUEyQixHQUFHLElBQUlDLE1BQUosQ0FBVyxnQ0FBWCxFQUE2QyxHQUE3QyxDQUFwQztBQUNBLE1BQU1DLDZCQUE2QixHQUFHLElBQUlELE1BQUosQ0FBWSxpQ0FBWixFQUE4QyxHQUE5QyxDQUF0QztBQUNBLE1BQU1FLDhCQUE4QixHQUFHLElBQUlGLE1BQUosQ0FBVyxnQ0FBWCxFQUE2QyxHQUE3QyxDQUF2QztBQUVBLE1BQU1HLFVBQVUsR0FBRyw4QkFBbkI7QUFRQVAsaUJBQWlCLENBQUNRLGdCQUFsQixHQUFxQ0MsZ0JBQUVDLE9BQUYsQ0FBVSxlQUFlRixnQkFBZixDQUFpQ0csVUFBakMsRUFBNkM7QUFDMUZDLGtCQUFJQyxJQUFKLENBQVUsb0JBQW1CRixVQUFXLGFBQXhDOztBQUNBLE1BQUksS0FBS0csT0FBVCxFQUFrQjtBQUNoQixXQUFPLE1BQU0sS0FBS0Msb0JBQUwsQ0FBMEJKLFVBQTFCLENBQWI7QUFDRDs7QUFDREMsa0JBQUlJLElBQUosQ0FBVSxzRUFBRCxHQUNDLGtFQURELEdBRUMseUNBQXdDTCxVQUFXLEdBRjdEOztBQUdBLFNBQU8sTUFBTSxLQUFLTSxpQkFBTCxDQUF1Qk4sVUFBdkIsQ0FBYjtBQUNELENBVG9DLENBQXJDO0FBa0JBWCxpQkFBaUIsQ0FBQ2tCLGVBQWxCLEdBQW9DVCxnQkFBRUMsT0FBRixDQUFVLFNBQVNRLGVBQVQsR0FBNEI7QUFDeEUsU0FBT0Msc0JB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SyxPQUFMLEVBQWMsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixPQUFuQixFQUE0QixLQUE1QixFQUFtQ2EsT0FBbkMsQ0FBZCxDQUF2QjtBQUNBTCxJQUFBQSxRQUFRLEdBQUc3SyxNQUFNLENBQUNGLElBQVAsRUFBWDtBQUNELEdBTEQsQ0FLRSxPQUFPOEQsR0FBUCxFQUFZO0FBQ1osVUFBTSxJQUFJL0QsS0FBSixDQUFXLHdDQUFELEdBQ0MsMERBREQsR0FFQyxtQkFBa0IrRCxHQUFHLENBQUM1QyxPQUFRLEVBRnpDLENBQU47QUFHRCxHQVRELFNBU1U7QUFDUixVQUFNdEIsa0JBQUdzTCxNQUFILENBQVVQLE9BQVYsQ0FBTjtBQUNEOztBQUNELFFBQU14SSxPQUFPLEdBQUc3QyxjQUFLK0wsS0FBTCxDQUFXOUwsT0FBWCxDQUFtQnJCLFVBQW5CLEVBQWdDLEdBQUU2TSxRQUFTLElBQTNDLENBQWhCOztBQUNBeE0sa0JBQUk4QixLQUFKLENBQVcsd0RBQXVEOEIsT0FBUSxHQUExRTs7QUFDQSxTQUFPLE1BQU0sS0FBS3dILFVBQUwsQ0FBZ0J4SCxPQUFoQixDQUFiO0FBQ0QsQ0F4QkQ7O2VBMEJleEUsaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyLmpzJztcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IHN5c3RlbSwgZnMsIHV0aWwsIHRlbXBEaXIgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQge1xuICBnZXRTZGtUb29sc1ZlcnNpb24sXG4gIGdldEJ1aWxkVG9vbHNEaXJzLFxuICBnZXRPcGVuU3NsRm9yT3MsXG4gIERFRkFVTFRfQURCX0VYRUNfVElNRU9VVCB9IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgZXhlYywgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyBzbGVlcCwgcmV0cnksIHJldHJ5SW50ZXJ2YWwsIHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgcXVvdGUgfSBmcm9tICdzaGVsbC1xdW90ZSc7XG5cblxubGV0IHN5c3RlbUNhbGxNZXRob2RzID0ge307XG5cbmNvbnN0IERFRkFVTFRfQURCX1JFQk9PVF9SRVRSSUVTID0gOTA7XG5cbmNvbnN0IExJTktFUl9XQVJOSU5HX1JFR0VYUCA9IC9eV0FSTklORzogbGlua2VyLiskL207XG5jb25zdCBQUk9UT0NPTF9GQVVMVF9FUlJPUl9SRUdFWFAgPSBuZXcgUmVnRXhwKCdwcm90b2NvbCBmYXVsdCBcXFxcKG5vIHN0YXR1c1xcXFwpJywgJ2knKTtcbmNvbnN0IERFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQID0gbmV3IFJlZ0V4cChgZXJyb3I6IGRldmljZSAoJy4rJyApP25vdCBmb3VuZGAsICdpJyk7XG5jb25zdCBERVZJQ0VfQ09OTkVDVElOR19FUlJPUl9SRUdFWFAgPSBuZXcgUmVnRXhwKCdlcnJvcjogZGV2aWNlIHN0aWxsIGNvbm5lY3RpbmcnLCAnaScpO1xuXG5jb25zdCBDRVJUU19ST09UID0gJy9zeXN0ZW0vZXRjL3NlY3VyaXR5L2NhY2VydHMnO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGJpbmFyeS5cbiAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBiaW5hcnkgaW5jbHVkaW5nIGN1cnJlbnQgU0RLIHJvb3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFNka0JpbmFyeVBhdGggPSBfLm1lbW9pemUoYXN5bmMgZnVuY3Rpb24gZ2V0U2RrQmluYXJ5UGF0aCAoYmluYXJ5TmFtZSkge1xuICBsb2cuaW5mbyhgQ2hlY2tpbmcgd2hldGhlciAke2JpbmFyeU5hbWV9IGlzIHByZXNlbnRgKTtcbiAgaWYgKHRoaXMuc2RrUm9vdCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEJpbmFyeUZyb21TZGtSb290KGJpbmFyeU5hbWUpO1xuICB9XG4gIGxvZy53YXJuKGBUaGUgQU5EUk9JRF9IT01FIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBzZXQgdG8gdGhlIEFuZHJvaWQgU0RLIGAgK1xuICAgICAgICAgICBgcm9vdCBkaXJlY3RvcnkgcGF0aC4gQU5EUk9JRF9IT01FIGlzIHJlcXVpcmVkIGZvciBjb21wYXRpYmlsaXR5IGAgK1xuICAgICAgICAgICBgd2l0aCBTREsgMjMrLiBDaGVja2luZyBhbG9uZyBQQVRIIGZvciAke2JpbmFyeU5hbWV9LmApO1xuICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCaW5hcnlGcm9tUGF0aChiaW5hcnlOYW1lKTtcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBuYW1lIG9mIHRoZSB0b29sLFxuICogd2hpY2ggcHJpbnRzIGZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gY29tbWFuZCBzaG9ydGN1dC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERlcGVuZGluZyBvbiB0aGUgY3VycmVudCBwbGF0Zm9ybSB0aGlzIGlzXG4gKiAgICAgICAgICAgICAgICAgIHN1cHBvc2VkIHRvIGJlIGVpdGhlciAnd2hpY2gnIG9yICd3aGVyZScuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldENvbW1hbmRGb3JPUyA9IF8ubWVtb2l6ZShmdW5jdGlvbiBnZXRDb21tYW5kRm9yT1MgKCkge1xuICByZXR1cm4gc3lzdGVtLmlzV2luZG93cygpID8gJ3doZXJlJyA6ICd3aGljaCc7XG59KTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIGJpbmFyeSBuYW1lIGZvciB0aGUgY3VycmVudCBvcGVyYXRpbmcgc3lzdGVtLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gc2ltcGxlIGJpbmFyeSBuYW1lLCBmb3IgZXhhbXBsZSAnYW5kcm9pZCcuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZvcm1hdHRlZCBiaW5hcnkgbmFtZSBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgcGxhdGZvcm0sXG4gKiAgICAgICAgICAgICAgICAgIGZvciBleGFtcGxlLCAnYW5kcm9pZC5iYXQnIG9uIFdpbmRvd3MuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeU5hbWVGb3JPUyA9IF8ubWVtb2l6ZShmdW5jdGlvbiBnZXRCaW5hcnlOYW1lRm9yT1MgKGJpbmFyeU5hbWUpIHtcbiAgaWYgKCFzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICByZXR1cm4gYmluYXJ5TmFtZTtcbiAgfVxuXG4gIGlmIChbJ2FuZHJvaWQnLCAnYXBrc2lnbmVyJywgJ2Fwa2FuYWx5emVyJ10uaW5kZXhPZihiaW5hcnlOYW1lKSA+PSAwICYmXG4gICAgICAhYmluYXJ5TmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuYmF0JykpIHtcbiAgICByZXR1cm4gYCR7YmluYXJ5TmFtZX0uYmF0YDtcbiAgfVxuICBpZiAoIWJpbmFyeU5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmV4ZScpKSB7XG4gICAgcmV0dXJuIGAke2JpbmFyeU5hbWV9LmV4ZWA7XG4gIH1cbiAgcmV0dXJuIGJpbmFyeU5hbWU7XG59KTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFNpbXBsZSBuYW1lIG9mIGEgYmluYXJ5IGZpbGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5LiBUaGUgbWV0aG9kIHRyaWVzXG4gKiAgICAgICAgICAgICAgICAgIHRvIGVudW1lcmF0ZSBhbGwgdGhlIGtub3duIGxvY2F0aW9ucyB3aGVyZSB0aGUgYmluYXJ5XG4gKiAgICAgICAgICAgICAgICAgIG1pZ2h0IGJlIGxvY2F0ZWQgYW5kIHN0b3BzIHRoZSBzZWFyY2ggYXMgc29vbiBhcyB0aGUgZmlyc3RcbiAqICAgICAgICAgICAgICAgICAgbWF0Y2ggaXMgZm91bmQgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBiaW5hcnkgd2l0aCBnaXZlbiBuYW1lIGlzIG5vdCBwcmVzZW50IGF0IGFueVxuICogICAgICAgICAgICAgICAgIG9mIGtub3duIGxvY2F0aW9ucyBvciBBbmRyb2lkIFNESyBpcyBub3QgaW5zdGFsbGVkIG9uIHRoZVxuICogICAgICAgICAgICAgICAgIGxvY2FsIGZpbGUgc3lzdGVtLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlGcm9tU2RrUm9vdCA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiBnZXRCaW5hcnlGcm9tU2RrUm9vdCAoYmluYXJ5TmFtZSkge1xuICBsZXQgYmluYXJ5TG9jID0gbnVsbDtcbiAgYmluYXJ5TmFtZSA9IHRoaXMuZ2V0QmluYXJ5TmFtZUZvck9TKGJpbmFyeU5hbWUpO1xuICBsZXQgYmluYXJ5TG9jcyA9IFtcbiAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCAncGxhdGZvcm0tdG9vbHMnLCBiaW5hcnlOYW1lKSxcbiAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCAnZW11bGF0b3InLCBiaW5hcnlOYW1lKSxcbiAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCAndG9vbHMnLCBiaW5hcnlOYW1lKSxcbiAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCAndG9vbHMnLCAnYmluJywgYmluYXJ5TmFtZSlcbiAgXTtcbiAgLy8gZ2V0IHN1YnBhdGhzIGZvciBjdXJyZW50bHkgaW5zdGFsbGVkIGJ1aWxkIHRvb2wgZGlyZWN0b3JpZXNcbiAgXy5mb3JFYWNoKGF3YWl0IGdldEJ1aWxkVG9vbHNEaXJzKHRoaXMuc2RrUm9vdCksXG4gICAgICAgICAgICAoZGlyKSA9PiBiaW5hcnlMb2NzLnB1c2gocGF0aC5yZXNvbHZlKGRpciwgYmluYXJ5TmFtZSkpKTtcbiAgZm9yIChsZXQgbG9jIG9mIGJpbmFyeUxvY3MpIHtcbiAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKGxvYykpIHtcbiAgICAgIGJpbmFyeUxvYyA9IGxvYztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoXy5pc051bGwoYmluYXJ5TG9jKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgJHtiaW5hcnlOYW1lfSBpbiAke2JpbmFyeUxvY3N9LiBgICtcbiAgICAgICAgICAgICAgICAgICAgYERvIHlvdSBoYXZlIHRoZSBBbmRyb2lkIFNESyBpbnN0YWxsZWQgYXQgJyR7dGhpcy5zZGtSb290fSc/YCk7XG4gIH1cbiAgYmluYXJ5TG9jID0gYmluYXJ5TG9jLnRyaW0oKTtcbiAgbG9nLmluZm8oYFVzaW5nICR7YmluYXJ5TmFtZX0gZnJvbSAke2JpbmFyeUxvY31gKTtcbiAgcmV0dXJuIGJpbmFyeUxvYztcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgcGF0aCB0byBhIGJpbmFyeSBmaWxlIHVzaW5nIHRoZSBzdGFuZGFyZCBzeXN0ZW0gbG9va3VwIHRvb2wuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYmluYXJ5LlxuICogQHJldHVybiB7c3RyaW5nfSBGdWxsIHBhdGggdG8gdGhlIGJpbmFyeSByZWNlaXZlZCBmcm9tICd3aGljaCcvJ3doZXJlJ1xuICogICAgICAgICAgICAgICAgICBvdXRwdXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbG9va3VwIHRvb2wgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QmluYXJ5RnJvbVBhdGggPSBhc3luYyBmdW5jdGlvbiBnZXRCaW5hcnlGcm9tUGF0aCAoYmluYXJ5TmFtZSkge1xuICBsZXQgYmluYXJ5TG9jID0gbnVsbDtcbiAgbGV0IGNtZCA9IHRoaXMuZ2V0Q29tbWFuZEZvck9TKCk7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhjbWQsIFtiaW5hcnlOYW1lXSk7XG4gICAgbG9nLmluZm8oYFVzaW5nICR7YmluYXJ5TmFtZX0gZnJvbSAke3N0ZG91dH1gKTtcbiAgICAvLyBUT0RPIHdyaXRlIGEgdGVzdCBmb3IgYmluYXJpZXMgd2l0aCBzcGFjZXMuXG4gICAgYmluYXJ5TG9jID0gc3Rkb3V0LnRyaW0oKTtcbiAgICByZXR1cm4gYmluYXJ5TG9jO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAke2JpbmFyeU5hbWV9IFBsZWFzZSBzZXQgdGhlIEFORFJPSURfSE9NRSBgICtcbiAgICAgICAgICAgICAgYGVudmlyb25tZW50IHZhcmlhYmxlIHdpdGggdGhlIEFuZHJvaWQgU0RLIHJvb3QgZGlyZWN0b3J5IHBhdGguYCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRGV2aWNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdWRpZCAtIFRoZSBkZXZpY2UgdWRpZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0ZSAtIEN1cnJlbnQgZGV2aWNlIHN0YXRlLCBhcyBpdCBpcyB2aXNpYmxlIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYWRiIGRldmljZXMgLWxfIG91dHB1dC5cbiAqL1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGRldmljZXMgdmlzaWJsZSB0byBhZGIuXG4gKlxuICogQHJldHVybiB7QXJyYXkuPERldmljZT59IFRoZSBsaXN0IG9mIGRldmljZXMgb3IgYW4gZW1wdHkgbGlzdCBpZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIG5vIGRldmljZXMgYXJlIGNvbm5lY3RlZC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbGlzdGluZyBkZXZpY2VzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRDb25uZWN0ZWREZXZpY2VzID0gYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGVkRGV2aWNlcyAoKSB7XG4gIGxvZy5kZWJ1ZygnR2V0dGluZyBjb25uZWN0ZWQgZGV2aWNlcy4uLicpO1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5jb25jYXQoWydkZXZpY2VzJ10pKTtcbiAgICAvLyBleHBlY3RpbmcgYWRiIGRldmljZXMgdG8gcmV0dXJuIG91dHB1dCBhc1xuICAgIC8vIExpc3Qgb2YgZGV2aWNlcyBhdHRhY2hlZFxuICAgIC8vIGVtdWxhdG9yLTU1NTRcdGRldmljZVxuICAgIGxldCBzdGFydGluZ0luZGV4ID0gc3Rkb3V0LmluZGV4T2YoJ0xpc3Qgb2YgZGV2aWNlcycpO1xuICAgIGlmIChzdGFydGluZ0luZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG91dHB1dCB3aGlsZSB0cnlpbmcgdG8gZ2V0IGRldmljZXMuIG91dHB1dCB3YXM6ICR7c3Rkb3V0fWApO1xuICAgIH1cbiAgICAvLyBzbGljaW5nIG91cHV0IHdlIGNhcmUgYWJvdXQuXG4gICAgc3Rkb3V0ID0gc3Rkb3V0LnNsaWNlKHN0YXJ0aW5nSW5kZXgpO1xuICAgIGxldCBkZXZpY2VzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzdGRvdXQuc3BsaXQoJ1xcbicpKSB7XG4gICAgICBpZiAobGluZS50cmltKCkgIT09ICcnICYmXG4gICAgICAgICAgbGluZS5pbmRleE9mKCdMaXN0IG9mIGRldmljZXMnKSA9PT0gLTEgJiZcbiAgICAgICAgICBsaW5lLmluZGV4T2YoJ2FkYiBzZXJ2ZXInKSA9PT0gLTEgJiZcbiAgICAgICAgICBsaW5lLmluZGV4T2YoJyogZGFlbW9uJykgPT09IC0xICYmXG4gICAgICAgICAgbGluZS5pbmRleE9mKCdvZmZsaW5lJykgPT09IC0xKSB7XG4gICAgICAgIGxldCBsaW5lSW5mbyA9IGxpbmUuc3BsaXQoJ1xcdCcpO1xuICAgICAgICAvLyBzdGF0ZSBpcyBlaXRoZXIgXCJkZXZpY2VcIiBvciBcIm9mZmxpbmVcIiwgYWZhaWN0XG4gICAgICAgIGRldmljZXMucHVzaCh7dWRpZDogbGluZUluZm9bMF0sIHN0YXRlOiBsaW5lSW5mb1sxXX0pO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2cuZGVidWcoYCR7ZGV2aWNlcy5sZW5ndGh9IGRldmljZShzKSBjb25uZWN0ZWRgKTtcbiAgICByZXR1cm4gZGV2aWNlcztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3Igd2hpbGUgZ2V0dGluZyBjb25uZWN0ZWQgZGV2aWNlcy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGRldmljZXMgdmlzaWJsZSB0byBhZGIgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGdldCBhdCBsZWFzdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZSBsaXN0IGl0ZW0uXG4gKiBAcmV0dXJuIHtBcnJheS48RGV2aWNlPn0gVGhlIGxpc3Qgb2YgY29ubmVjdGVkIGRldmljZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbm8gY29ubmVjdGVkIGRldmljZXMgY2FuIGJlIGRldGVjdGVkIHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0RGV2aWNlc1dpdGhSZXRyeSA9IGFzeW5jIGZ1bmN0aW9uIGdldERldmljZXNXaXRoUmV0cnkgKHRpbWVvdXRNcyA9IDIwMDAwKSB7XG4gIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gIGxvZy5kZWJ1ZygnVHJ5aW5nIHRvIGZpbmQgYSBjb25uZWN0ZWQgYW5kcm9pZCBkZXZpY2UnKTtcbiAgbGV0IGdldERldmljZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKChEYXRlLm5vdygpIC0gc3RhcnQpID4gdGltZW91dE1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGVkIEFuZHJvaWQgZGV2aWNlLicpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICAgIGlmIChkZXZpY2VzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgbG9nLmRlYnVnKCdDb3VsZCBub3QgZmluZCBkZXZpY2VzLCByZXN0YXJ0aW5nIGFkYiBzZXJ2ZXIuLi4nKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICAgIC8vIGNvb2wgZG93blxuICAgICAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgICAgICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRldmljZXM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nLmRlYnVnKCdDb3VsZCBub3QgZmluZCBkZXZpY2VzLCByZXN0YXJ0aW5nIGFkYiBzZXJ2ZXIuLi4nKTtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgLy8gY29vbCBkb3duXG4gICAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgICAgcmV0dXJuIGF3YWl0IGdldERldmljZXMoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBhd2FpdCBnZXREZXZpY2VzKCk7XG59O1xuXG4vKipcbiAqIFJlc3RhcnQgYWRiIHNlcnZlciwgdW5sZXNzIF90aGlzLnN1cHByZXNzS2lsbFNlcnZlcl8gcHJvcGVydHkgaXMgdHJ1ZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMucmVzdGFydEFkYiA9IGFzeW5jIGZ1bmN0aW9uIHJlc3RhcnRBZGIgKCkge1xuICBpZiAodGhpcy5zdXBwcmVzc0tpbGxTZXJ2ZXIpIHtcbiAgICBsb2cuZGVidWcoYE5vdCByZXN0YXJ0aW5nIGFiZCBzaW5jZSAnc3VwcHJlc3NLaWxsU2VydmVyJyBpcyBvbmApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZygnUmVzdGFydGluZyBhZGInKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLmtpbGxTZXJ2ZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvcihcIkVycm9yIGtpbGxpbmcgQURCIHNlcnZlciwgZ29pbmcgdG8gc2VlIGlmIGl0J3Mgb25saW5lIGFueXdheVwiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBLaWxsIGFkYiBzZXJ2ZXIuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxTZXJ2ZXIgPSBhc3luYyBmdW5jdGlvbiBraWxsU2VydmVyICgpIHtcbiAgbG9nLmRlYnVnKGBLaWxsaW5nIGFkYiBzZXJ2ZXIgb24gcG9ydCAke3RoaXMuYWRiUG9ydH1gKTtcbiAgYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgWy4uLnRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncywgJ2tpbGwtc2VydmVyJ10pO1xufTtcblxuLyoqXG4gKiBSZXNldCBUZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW4uXG4gKiBAc2VlIHtAbGluayBodHRwOi8vdG9vbHMuYW5kcm9pZC5jb20vcmVjZW50L2VtdWxhdG9yMjUxNnJlbGVhc2Vub3Rlc30gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdG9rZW4gcmVzZXQgd2FzIHN1Y2Nlc3NmdWwuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlc2V0VGVsbmV0QXV0aFRva2VuID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uIHJlc2V0VGVsbmV0QXV0aFRva2VuICgpIHtcbiAgLy8gVGhlIG1ldGhvZHMgaXMgdXNlZCB0byByZW1vdmUgdGVsbmV0IGF1dGggdG9rZW5cbiAgLy9cbiAgY29uc3QgaG9tZUZvbGRlclBhdGggPSBwcm9jZXNzLmVudlsocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykgPyAnVVNFUlBST0ZJTEUnIDogJ0hPTUUnXTtcbiAgaWYgKCFob21lRm9sZGVyUGF0aCkge1xuICAgIGxvZy53YXJuKGBDYW5ub3QgZmluZCB0aGUgcGF0aCB0byB1c2VyIGhvbWUgZm9sZGVyLiBJZ25vcmluZyByZXNldHRpbmcgb2YgZW11bGF0b3IncyB0ZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShob21lRm9sZGVyUGF0aCwgJy5lbXVsYXRvcl9jb25zb2xlX2F1dGhfdG9rZW4nKTtcbiAgbG9nLmRlYnVnKGBPdmVycmlkaW5nICR7ZHN0UGF0aH0gd2l0aCBhbiBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIGZvciBlbXVsYXRvciBjb21tYW5kc2ApO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cud2FybihgRXJyb3IgJHtlLm1lc3NhZ2V9IHdoaWxlIHJlc2V0dGluZyB0aGUgY29udGVudCBvZiAke2RzdFBhdGh9LiBJZ25vcmluZyByZXNldHRpbmcgb2YgZW11bGF0b3IncyB0ZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBlbXVsYXRvciBjb21tYW5kIHVzaW5nIF9hZGIgZW11XyB0b29sLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNtZCAtIFRoZSBhcnJheSBvZiByZXN0IGNvbW1hbmQgbGluZSBwYXJhbWV0ZXJzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5hZGJFeGVjRW11ID0gYXN5bmMgZnVuY3Rpb24gYWRiRXhlY0VtdSAoY21kKSB7XG4gIGF3YWl0IHRoaXMudmVyaWZ5RW11bGF0b3JDb25uZWN0ZWQoKTtcbiAgYXdhaXQgdGhpcy5yZXNldFRlbG5ldEF1dGhUb2tlbigpO1xuICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydlbXUnLCAuLi5jbWRdKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gYWRiIGNvbW1hbmQuXG4gKlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY21kIC0gVGhlIGFycmF5IG9mIHJlc3QgY29tbWFuZCBsaW5lIHBhcmFtZXRlcnNcbiAqICAgICAgICAgICAgICAgICAgICAgIG9yIGEgc2luZ2xlIHN0cmluZyBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBtYXBwaW5nLiBTZWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vbm9kZS10ZWVuX3Byb2Nlc3N9XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gQ29tbWFuZCdzIHN0ZG91dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29tbWFuZCByZXR1cm5lZCBub24temVybyBleGl0IGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmFkYkV4ZWMgPSBhc3luYyBmdW5jdGlvbiBhZGJFeGVjIChjbWQsIG9wdHMgPSB7fSkge1xuICBpZiAoIWNtZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcGFzcyBpbiBhIGNvbW1hbmQgdG8gYWRiRXhlYygpJyk7XG4gIH1cblxuICAvLyBzZXR0aW5nIGRlZmF1bHQgdGltZW91dCBmb3IgZWFjaCBjb21tYW5kIHRvIHByZXZlbnQgaW5maW5pdGUgd2FpdC5cbiAgb3B0cy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IHRoaXMuYWRiRXhlY1RpbWVvdXQgfHwgREVGQVVMVF9BREJfRVhFQ19USU1FT1VUO1xuICBvcHRzLnRpbWVvdXRDYXBOYW1lID0gb3B0cy50aW1lb3V0Q2FwTmFtZSB8fCAnYWRiRXhlY1RpbWVvdXQnOyAvLyBGb3IgZXJyb3IgbWVzc2FnZVxuXG4gIGNtZCA9IF8uaXNBcnJheShjbWQpID8gY21kIDogW2NtZF07XG5cbiAgbGV0IGFkYlJldHJpZWQgPSBmYWxzZTtcbiAgY29uc3QgZXhlY0Z1bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MuY29uY2F0KGNtZCk7XG4gICAgICBsb2cuZGVidWcoYFJ1bm5pbmcgJyR7dGhpcy5leGVjdXRhYmxlLnBhdGh9ICR7cXVvdGUoYXJncyl9J2ApO1xuICAgICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgYXJncywgb3B0cyk7XG4gICAgICAvLyBzb21ldGltZXMgQURCIHByaW50cyBvdXQgd2VpcmQgc3Rkb3V0IHdhcm5pbmdzIHRoYXQgd2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gdG8gaW5jbHVkZSBpbiBhbnkgb2YgdGhlIHJlc3BvbnNlIGRhdGEsIHNvIGxldCdzIHN0cmlwIGl0IG91dFxuICAgICAgc3Rkb3V0ID0gc3Rkb3V0LnJlcGxhY2UoTElOS0VSX1dBUk5JTkdfUkVHRVhQLCAnJykudHJpbSgpO1xuICAgICAgcmV0dXJuIHN0ZG91dDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zdCBlcnJUZXh0ID0gYCR7ZS5tZXNzYWdlfSwgJHtlLnN0ZG91dH0sICR7ZS5zdGRlcnJ9YDtcbiAgICAgIGNvbnN0IHByb3RvY29sRmF1bHRFcnJvciA9IFBST1RPQ09MX0ZBVUxUX0VSUk9SX1JFR0VYUC50ZXN0KGVyclRleHQpO1xuICAgICAgY29uc3QgZGV2aWNlTm90Rm91bmRFcnJvciA9IERFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQLnRlc3QoZXJyVGV4dCk7XG4gICAgICBjb25zdCBkZXZpY2VDb25uZWN0aW5nRXJyb3IgPSBERVZJQ0VfQ09OTkVDVElOR19FUlJPUl9SRUdFWFAudGVzdChlcnJUZXh0KTtcbiAgICAgIGlmIChwcm90b2NvbEZhdWx0RXJyb3IgfHwgZGV2aWNlTm90Rm91bmRFcnJvciB8fCBkZXZpY2VDb25uZWN0aW5nRXJyb3IpIHtcbiAgICAgICAgbG9nLmluZm8oYEVycm9yIHNlbmRpbmcgY29tbWFuZCwgcmVjb25uZWN0aW5nIGRldmljZSBhbmQgcmV0cnlpbmc6ICR7Y21kfWApO1xuICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKTtcbiAgICAgICAgYXdhaXQgdGhpcy5nZXREZXZpY2VzV2l0aFJldHJ5KCk7XG5cbiAgICAgICAgLy8gdHJ5IGFnYWluIG9uZSB0aW1lXG4gICAgICAgIGlmIChhZGJSZXRyaWVkKSB7XG4gICAgICAgICAgYWRiUmV0cmllZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGV4ZWNGdW5jKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGUuY29kZSA9PT0gMCAmJiBlLnN0ZG91dCkge1xuICAgICAgICByZXR1cm4gZS5zdGRvdXQucmVwbGFjZShMSU5LRVJfV0FSTklOR19SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzTnVsbChlLmNvZGUpKSB7XG4gICAgICAgIGUubWVzc2FnZSA9IGBFcnJvciBleGVjdXRpbmcgYWRiRXhlYy4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nLiBgICtcbiAgICAgICAgICBgVHJ5IHRvIGluY3JlYXNlIHRoZSAke29wdHMudGltZW91dH1tcyBhZGIgZXhlY3V0aW9uIHRpbWVvdXQgcmVwcmVzZW50ZWQgYnkgJyR7b3B0cy50aW1lb3V0Q2FwTmFtZX0nIGNhcGFiaWxpdHlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS5tZXNzYWdlID0gYEVycm9yIGV4ZWN1dGluZyBhZGJFeGVjLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSc7IGAgK1xuICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYDtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBhd2FpdCBleGVjRnVuYygpO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTaGVsbEV4ZWNPcHRpb25zXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBwcml2aWxlZ2VkIFtmYWxzeV0gLSBXaGV0aGVyIHRvIHJ1biB0aGUgZ2l2ZW4gY29tbWFuZCBhcyByb290LlxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0ga2VlcFByaXZpbGVnZWQgW2ZhbHN5XSAtIFdoZXRoZXIgdG8ga2VlcCByb290IG1vZGUgYWZ0ZXIgY29tbWFuZCBleGVjdXRpb24gaXMgY29tcGxldGVkLlxuICpcbiAqIEFsbCBvdGhlciBwcm9wZXJ0aWVzIGFyZSB0aGUgc2FtZSBhcyBmb3IgYGV4ZWNgIGNhbGwgZnJvbSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqIG1vZHVsZVxuICovXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gY29tbWFuZCB1c2luZyBfYWRiIHNoZWxsXyBwcmVmaXguXG4gKlxuICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz58c3RyaW5nfSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVycyBvciBhIHNpbmdsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0gez9TaGVsbEV4ZWNPcHRpb25zfSBvcHRzIFt7fV0gLSBBZGRpdGlvbmFsIG9wdGlvbnMgbWFwcGluZy5cbiAqIEByZXR1cm4ge3N0cmluZ30gLSBDb21tYW5kJ3Mgc3Rkb3V0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb21tYW5kIHJldHVybmVkIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2hlbGwgPSBhc3luYyBmdW5jdGlvbiBzaGVsbCAoY21kLCBvcHRzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHByaXZpbGVnZWQsXG4gICAga2VlcFByaXZpbGVnZWQsXG4gIH0gPSBvcHRzO1xuICBsZXQgc2hvdWxkUmVzdG9yZVVzZXIgPSBmYWxzZTtcbiAgaWYgKHByaXZpbGVnZWQpIHtcbiAgICB0cnkge1xuICAgICAgc2hvdWxkUmVzdG9yZVVzZXIgPSAhKGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3Jvb3QnXSwgb3B0cykpLmluY2x1ZGVzKCdhbHJlYWR5IHJ1bm5pbmcgYXMgcm9vdCcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFlcnIubWVzc2FnZS5pbmNsdWRlcygnYWRiZCBjYW5ub3QgcnVuIGFzIHJvb3QnKSkge1xuICAgICAgICAvLyBEbyBub3Qgc2hvdyB0aGUgd2FybmluZyBmb3IgcmVhbCBkZXZpY2VzLCB3aGVyZSByb290IGlzIGxvY2tlZFxuICAgICAgICBsb2cud2FybihgQ2Fubm90IHJ1biBhZGJkIGFzIHJvb3QuIE9yaWdpbmFsIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgZGlkQ29tbWFuZEZhaWwgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYWRiRXhlYyhfLmlzQXJyYXkoY21kKSA/IFsnc2hlbGwnLCAuLi5jbWRdIDogWydzaGVsbCcsIGNtZF0sIG9wdHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZGlkQ29tbWFuZEZhaWwgPSB0cnVlO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAocHJpdmlsZWdlZCAmJiBzaG91bGRSZXN0b3JlVXNlciAmJiAoIWtlZXBQcml2aWxlZ2VkIHx8IGRpZENvbW1hbmRGYWlsKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5hZGJFeGVjKFsndW5yb290J10sIG9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy53YXJuKGBDYW5ub3QgcnVuIGFkYmQgYXMgbm9uLXJvb3QuIE9yaWdpbmFsIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuc3lzdGVtQ2FsbE1ldGhvZHMuY3JlYXRlU3ViUHJvY2VzcyA9IGZ1bmN0aW9uIGNyZWF0ZVN1YlByb2Nlc3MgKGFyZ3MgPSBbXSkge1xuICAvLyBhZGQgdGhlIGRlZmF1bHQgYXJndW1lbnRzXG4gIGFyZ3MgPSB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MuY29uY2F0KGFyZ3MpO1xuICBsb2cuZGVidWcoYENyZWF0aW5nIEFEQiBzdWJwcm9jZXNzIHdpdGggYXJnczogJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKTtcbiAgcmV0dXJuIG5ldyBTdWJQcm9jZXNzKHRoaXMuZ2V0QWRiUGF0aCgpLCBhcmdzKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgYWRiIHBvcnQuXG4gKiBAdG9kbyBjYW4gcHJvYmFibHkgZGVwcmVjYXRlIHRoaXMgbm93IHRoYXQgdGhlIGxvZ2ljIGlzIGp1c3QgdG8gcmVhZCB0aGlzLmFkYlBvcnRcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGN1cnJlbnQgYWRiIHBvcnQgbnVtYmVyLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRBZGJTZXJ2ZXJQb3J0ID0gZnVuY3Rpb24gZ2V0QWRiU2VydmVyUG9ydCAoKSB7XG4gIHJldHVybiB0aGlzLmFkYlBvcnQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgZnJvbSBfYWRiIGRldml2ZXNfIG91dHB1dC5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgYXJlIG5vIGNvbm5lY3RlZCBkZXZpY2VzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRFbXVsYXRvclBvcnQgPSBhc3luYyBmdW5jdGlvbiBnZXRFbXVsYXRvclBvcnQgKCkge1xuICBsb2cuZGVidWcoJ0dldHRpbmcgcnVubmluZyBlbXVsYXRvciBwb3J0Jyk7XG4gIGlmICh0aGlzLmVtdWxhdG9yUG9ydCAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVtdWxhdG9yUG9ydDtcbiAgfVxuICB0cnkge1xuICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgbGV0IHBvcnQgPSB0aGlzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcoZGV2aWNlc1swXS51ZGlkKTtcbiAgICBpZiAocG9ydCkge1xuICAgICAgcmV0dXJuIHBvcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRW11bGF0b3IgcG9ydCBub3QgZm91bmRgKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRldmljZXMgY29ubmVjdGVkLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydCBieSBwYXJzaW5nIGVtdWxhdG9yIG5hbWUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbVN0ciAtIEVtdWxhdG9yIG5hbWUgc3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59IEVpdGhlciB0aGUgY3VycmVudCBlbXVsYXRvciBwb3J0IG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZhbHNlXyBpZiBwb3J0IG51bWJlciBjYW5ub3QgYmUgcGFyc2VkLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nID0gZnVuY3Rpb24gZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyAoZW1TdHIpIHtcbiAgbGV0IHBvcnRQYXR0ZXJuID0gL2VtdWxhdG9yLShcXGQrKS87XG4gIGlmIChwb3J0UGF0dGVybi50ZXN0KGVtU3RyKSkge1xuICAgIHJldHVybiBwYXJzZUludChwb3J0UGF0dGVybi5leGVjKGVtU3RyKVsxXSwgMTApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgY3VycmVudGx5IGNvbm5lY3RlZCBlbXVsYXRvcnMuXG4gKlxuICogQHJldHVybiB7QXJyYXkuPERldmljZT59IFRoZSBsaXN0IG9mIGNvbm5lY3RlZCBkZXZpY2VzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRDb25uZWN0ZWRFbXVsYXRvcnMgPSBhc3luYyBmdW5jdGlvbiBnZXRDb25uZWN0ZWRFbXVsYXRvcnMgKCkge1xuICBsb2cuZGVidWcoJ0dldHRpbmcgY29ubmVjdGVkIGVtdWxhdG9ycycpO1xuICB0cnkge1xuICAgIGxldCBkZXZpY2VzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgbGV0IGVtdWxhdG9ycyA9IFtdO1xuICAgIGZvciAobGV0IGRldmljZSBvZiBkZXZpY2VzKSB7XG4gICAgICBsZXQgcG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2UudWRpZCk7XG4gICAgICBpZiAocG9ydCkge1xuICAgICAgICBkZXZpY2UucG9ydCA9IHBvcnQ7XG4gICAgICAgIGVtdWxhdG9ycy5wdXNoKGRldmljZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgJHtlbXVsYXRvcnMubGVuZ3RofSBlbXVsYXRvcihzKSBjb25uZWN0ZWRgKTtcbiAgICByZXR1cm4gZW11bGF0b3JzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGVtdWxhdG9ycy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBfZW11bGF0b3JQb3J0XyBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZW1Qb3J0IC0gVGhlIGVtdWxhdG9yIHBvcnQgdG8gYmUgc2V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zZXRFbXVsYXRvclBvcnQgPSBmdW5jdGlvbiBzZXRFbXVsYXRvclBvcnQgKGVtUG9ydCkge1xuICB0aGlzLmVtdWxhdG9yUG9ydCA9IGVtUG9ydDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBpZGVudGlmaWVyIG9mIHRoZSBjdXJyZW50IGRldmljZSAoX3RoaXMuY3VyRGV2aWNlSWRfKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gLSBUaGUgZGV2aWNlIGlkZW50aWZpZXIuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldERldmljZUlkID0gZnVuY3Rpb24gc2V0RGV2aWNlSWQgKGRldmljZUlkKSB7XG4gIGxvZy5kZWJ1ZyhgU2V0dGluZyBkZXZpY2UgaWQgdG8gJHtkZXZpY2VJZH1gKTtcbiAgdGhpcy5jdXJEZXZpY2VJZCA9IGRldmljZUlkO1xuICBsZXQgYXJnc0hhc0RldmljZSA9IHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5pbmRleE9mKCctcycpO1xuICBpZiAoYXJnc0hhc0RldmljZSAhPT0gLTEpIHtcbiAgICAvLyByZW1vdmUgdGhlIG9sZCBkZXZpY2UgaWQgZnJvbSB0aGUgYXJndW1lbnRzXG4gICAgdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLnNwbGljZShhcmdzSGFzRGV2aWNlLCAyKTtcbiAgfVxuICB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MucHVzaCgnLXMnLCBkZXZpY2VJZCk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdGhlIGN1cnJlbnQgZGV2aWNlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0RldmljZX0gZGV2aWNlT2JqIC0gVGhlIGRldmljZSBvYmplY3QgdG8gYmUgc2V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zZXREZXZpY2UgPSBmdW5jdGlvbiBzZXREZXZpY2UgKGRldmljZU9iaikge1xuICBsZXQgZGV2aWNlSWQgPSBkZXZpY2VPYmoudWRpZDtcbiAgbGV0IGVtUG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2VJZCk7XG4gIHRoaXMuc2V0RW11bGF0b3JQb3J0KGVtUG9ydCk7XG4gIHRoaXMuc2V0RGV2aWNlSWQoZGV2aWNlSWQpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG9iamVjdCBmb3IgdGhlIGN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdmROYW1lIC0gRW11bGF0b3IgbmFtZS5cbiAqIEByZXR1cm4gez9EZXZpY2V9IEN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yIG9yIF9udWxsXy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UnVubmluZ0FWRCA9IGFzeW5jIGZ1bmN0aW9uIGdldFJ1bm5pbmdBVkQgKGF2ZE5hbWUpIHtcbiAgbG9nLmRlYnVnKGBUcnlpbmcgdG8gZmluZCAke2F2ZE5hbWV9IGVtdWxhdG9yYCk7XG4gIHRyeSB7XG4gICAgbGV0IGVtdWxhdG9ycyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRW11bGF0b3JzKCk7XG4gICAgZm9yIChsZXQgZW11bGF0b3Igb2YgZW11bGF0b3JzKSB7XG4gICAgICB0aGlzLnNldEVtdWxhdG9yUG9ydChlbXVsYXRvci5wb3J0KTtcbiAgICAgIGxldCBydW5uaW5nQVZETmFtZSA9IGF3YWl0IHRoaXMuc2VuZFRlbG5ldENvbW1hbmQoJ2F2ZCBuYW1lJyk7XG4gICAgICBpZiAoYXZkTmFtZSA9PT0gcnVubmluZ0FWRE5hbWUpIHtcbiAgICAgICAgbG9nLmRlYnVnKGBGb3VuZCBlbXVsYXRvciAke2F2ZE5hbWV9IGluIHBvcnQgJHtlbXVsYXRvci5wb3J0fWApO1xuICAgICAgICB0aGlzLnNldERldmljZUlkKGVtdWxhdG9yLnVkaWQpO1xuICAgICAgICByZXR1cm4gZW11bGF0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgRW11bGF0b3IgJHthdmROYW1lfSBub3QgcnVubmluZ2ApO1xuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIEFWRC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF2ZE5hbWUgLSBFbXVsYXRvciBuYW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyBbMjAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gd2FpdCB1bnRpbCBhdCBsZWFzdCBvbmUgcnVubmluZyBBVkQgb2JqZWN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBkZXRlY3RlZC5cbiAqIEByZXR1cm4gez9EZXZpY2V9IEN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yIG9yIF9udWxsXy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBubyBkZXZpY2UgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIHRoZSB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gZ2V0UnVubmluZ0FWRFdpdGhSZXRyeSAoYXZkTmFtZSwgdGltZW91dE1zID0gMjAwMDApIHtcbiAgbGV0IHJ1bm5pbmdBdmQ7XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBydW5uaW5nQXZkID0gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEKGF2ZE5hbWUucmVwbGFjZSgnQCcsICcnKSk7XG4gICAgICAgIHJldHVybiBydW5uaW5nQXZkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cuZGVidWcoZS5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHdhaXRNczogdGltZW91dE1zLFxuICAgICAgaW50ZXJ2YWxNczogMTAwMCxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBBVkQgd2l0aCByZXRyeS4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG4gIHJldHVybiBydW5uaW5nQXZkO1xufTtcblxuLyoqXG4gKiBTaHV0ZG93biBhbGwgcnVubmluZyBlbXVsYXRvcnMgYnkga2lsbGluZyB0aGVpciBwcm9jZXNzZXMuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IElmIGtpbGxpbmcgdG9vbCByZXR1cm5lZCBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMua2lsbEFsbEVtdWxhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uIGtpbGxBbGxFbXVsYXRvcnMgKCkge1xuICBsZXQgY21kLCBhcmdzO1xuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgY21kID0gJ1RBU0tLSUxMJztcbiAgICBhcmdzID0gWydUQVNLS0lMTCcsICcvSU0nLCAnZW11bGF0b3IuZXhlJ107XG4gIH0gZWxzZSB7XG4gICAgY21kID0gJy91c3IvYmluL2tpbGxhbGwnO1xuICAgIGFyZ3MgPSBbJy1tJywgJ2VtdWxhdG9yKiddO1xuICB9XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyhjbWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBraWxsaW5nIGVtdWxhdG9ycy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEtpbGwgZW11bGF0b3Igd2l0aCB0aGUgZ2l2ZW4gbmFtZS4gTm8gZXJyb3JcbiAqIGlzIHRocm93biBpcyBnaXZlbiBhdmQgZG9lcyBub3QgZXhpc3QvaXMgbm90IHJ1bm5pbmcuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSBhdmROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVtdWxhdG9yIHRvIGJlIGtpbGxlZC4gSWYgZW1wdHksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY3VycmVudCBlbXVsYXRvciB3aWxsIGJlIGtpbGxlZC5cbiAqIEBwYXJhbSB7P251bWJlcn0gdGltZW91dCBbNjAwMDBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIHRocm93aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuIGV4Y2VwdGlvbiBhYm91dCB1bnN1Y2Nlc3NmdWwga2lsbGluZ1xuICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBlbXVsYXRvciB3YXMga2lsbGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGEgZmFpbHVyZSBieSBraWxsaW5nIHRoZSBlbXVsYXRvclxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsRW11bGF0b3IgPSBhc3luYyBmdW5jdGlvbiBraWxsRW11bGF0b3IgKGF2ZE5hbWUgPSBudWxsLCB0aW1lb3V0ID0gNjAwMDApIHtcbiAgaWYgKHV0aWwuaGFzVmFsdWUoYXZkTmFtZSkpIHtcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYXZkICcke2F2ZE5hbWV9J2ApO1xuICAgIGNvbnN0IGRldmljZSA9IGF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRChhdmROYW1lKTtcbiAgICBpZiAoIWRldmljZSkge1xuICAgICAgbG9nLmluZm8oYE5vIGF2ZCB3aXRoIG5hbWUgJyR7YXZkTmFtZX0nIHJ1bm5pbmcuIFNraXBwaW5nIGtpbGwgc3RlcC5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8ga2lsbGluZyB0aGUgY3VycmVudCBhdmRcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYXZkIHdpdGggaWQgJyR7dGhpcy5jdXJEZXZpY2VJZH0nYCk7XG4gICAgaWYgKCFhd2FpdCB0aGlzLmlzRW11bGF0b3JDb25uZWN0ZWQoKSkge1xuICAgICAgbG9nLmRlYnVnKGBFbXVsYXRvciB3aXRoIGlkICcke3RoaXMuY3VyRGV2aWNlSWR9JyBub3QgY29ubmVjdGVkLiBTa2lwcGluZyBraWxsIHN0ZXBgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnZW11JywgJ2tpbGwnXSk7XG4gIGxvZy5kZWJ1ZyhgV2FpdGluZyB1cCB0byAke3RpbWVvdXR9bXMgdW50aWwgdGhlIGVtdWxhdG9yICcke2F2ZE5hbWUgPyBhdmROYW1lIDogdGhpcy5jdXJEZXZpY2VJZH0nIGlzIGtpbGxlZGApO1xuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHV0aWwuaGFzVmFsdWUoYXZkTmFtZSlcbiAgICAgICAgICA/ICFhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkQoYXZkTmFtZSlcbiAgICAgICAgICA6ICFhd2FpdCB0aGlzLmlzRW11bGF0b3JDb25uZWN0ZWQoKTtcbiAgICAgIH0gY2F0Y2ggKGlnbikge31cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCB7XG4gICAgICB3YWl0TXM6IHRpbWVvdXQsXG4gICAgICBpbnRlcnZhbE1zOiAyMDAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZW11bGF0b3IgJyR7YXZkTmFtZSA/IGF2ZE5hbWUgOiB0aGlzLmN1ckRldmljZUlkfScgaXMgc3RpbGwgcnVubmluZyBhZnRlciBiZWluZyBraWxsZWQgJHt0aW1lb3V0fW1zIGFnb2ApO1xuICB9XG4gIGxvZy5pbmZvKGBTdWNjZXNzZnVsbHkga2lsbGVkIHRoZSAnJHthdmROYW1lID8gYXZkTmFtZSA6IHRoaXMuY3VyRGV2aWNlSWR9JyBlbXVsYXRvcmApO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogU3RhcnQgYW4gZW11bGF0b3Igd2l0aCBnaXZlbiBwYXJhbWV0ZXJzIGFuZCB3YWl0IHVudGlsIGl0IGlzIGZ1bGwgc3RhcnRlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIFRoZSBuYW1lIG9mIGFuIGV4aXN0aW5nIGVtdWxhdG9yLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPnxzdHJpbmd9IGF2ZEFyZ3MgLSBBZGRpdGlvbmFsIGVtdWxhdG9yIGNvbW1hbmQgbGluZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7P3N0cmluZ30gbGFuZ3VhZ2UgLSBFbXVsYXRvciBzeXN0ZW0gbGFuZ3VhZ2UuXG4gKiBAcGFyYW0gez9jb3VudHJ5fSBjb3VudHJ5IC0gRW11bGF0b3Igc3lzdGVtIGNvdW50cnkuXG4gKiBAcGFyYW0ge251bWJlcn0gYXZkTGF1bmNoVGltZW91dCBbNjAwMDBdIC0gRW11bGF0b3Igc3RhcnR1cCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXRyeVRpbWVzIFsxXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzdGFydHVwIHJldHJpZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGVtdWxhdG9yIGZhaWxzIHRvIHN0YXJ0IHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMubGF1bmNoQVZEID0gYXN5bmMgZnVuY3Rpb24gbGF1bmNoQVZEIChhdmROYW1lLCBhdmRBcmdzLCBsYW5ndWFnZSwgY291bnRyeSxcbiAgYXZkTGF1bmNoVGltZW91dCA9IDYwMDAwLCBhdmRSZWFkeVRpbWVvdXQgPSA2MDAwMCwgcmV0cnlUaW1lcyA9IDEpIHtcbiAgbG9nLmRlYnVnKGBMYXVuY2hpbmcgRW11bGF0b3Igd2l0aCBBVkQgJHthdmROYW1lfSwgbGF1bmNoVGltZW91dCBgICtcbiAgICAgICAgICAgIGAke2F2ZExhdW5jaFRpbWVvdXR9bXMgYW5kIHJlYWR5VGltZW91dCAke2F2ZFJlYWR5VGltZW91dH1tc2ApO1xuICBsZXQgZW11bGF0b3JCaW5hcnlQYXRoID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKCdlbXVsYXRvcicpO1xuICBpZiAoYXZkTmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgYXZkTmFtZSA9IGF2ZE5hbWUuc3Vic3RyKDEpO1xuICB9XG4gIGF3YWl0IHRoaXMuY2hlY2tBdmRFeGlzdChhdmROYW1lKTtcbiAgbGV0IGxhdW5jaEFyZ3MgPSBbJy1hdmQnLCBhdmROYW1lXTtcbiAgaWYgKF8uaXNTdHJpbmcobGFuZ3VhZ2UpKSB7XG4gICAgbG9nLmRlYnVnKGBTZXR0aW5nIEFuZHJvaWQgRGV2aWNlIExhbmd1YWdlIHRvICR7bGFuZ3VhZ2V9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKCctcHJvcCcsIGBwZXJzaXN0LnN5cy5sYW5ndWFnZT0ke2xhbmd1YWdlLnRvTG93ZXJDYXNlKCl9YCk7XG4gIH1cbiAgaWYgKF8uaXNTdHJpbmcoY291bnRyeSkpIHtcbiAgICBsb2cuZGVidWcoYFNldHRpbmcgQW5kcm9pZCBEZXZpY2UgQ291bnRyeSB0byAke2NvdW50cnl9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKCctcHJvcCcsIGBwZXJzaXN0LnN5cy5jb3VudHJ5PSR7Y291bnRyeS50b1VwcGVyQ2FzZSgpfWApO1xuICB9XG4gIGxldCBsb2NhbGU7XG4gIGlmIChfLmlzU3RyaW5nKGxhbmd1YWdlKSAmJiBfLmlzU3RyaW5nKGNvdW50cnkpKSB7XG4gICAgbG9jYWxlID0gbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKSArICctJyArIGNvdW50cnkudG9VcHBlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGxhbmd1YWdlKSkge1xuICAgIGxvY2FsZSA9IGxhbmd1YWdlLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhjb3VudHJ5KSkge1xuICAgIGxvY2FsZSA9IGNvdW50cnk7XG4gIH1cbiAgaWYgKF8uaXNTdHJpbmcobG9jYWxlKSkge1xuICAgIGxvZy5kZWJ1ZyhgU2V0dGluZyBBbmRyb2lkIERldmljZSBMb2NhbGUgdG8gJHtsb2NhbGV9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKCctcHJvcCcsIGBwZXJzaXN0LnN5cy5sb2NhbGU9JHtsb2NhbGV9YCk7XG4gIH1cbiAgaWYgKCFfLmlzRW1wdHkoYXZkQXJncykpIHtcbiAgICBsYXVuY2hBcmdzLnB1c2goLi4uKF8uaXNBcnJheShhdmRBcmdzKSA/IGF2ZEFyZ3MgOiBhdmRBcmdzLnNwbGl0KCcgJykpKTtcbiAgfVxuICBsb2cuZGVidWcoYFJ1bm5pbmcgJyR7ZW11bGF0b3JCaW5hcnlQYXRofScgd2l0aCBhcmdzOiAke0pTT04uc3RyaW5naWZ5KGxhdW5jaEFyZ3MpfWApO1xuICBsZXQgcHJvYyA9IG5ldyBTdWJQcm9jZXNzKGVtdWxhdG9yQmluYXJ5UGF0aCwgbGF1bmNoQXJncyk7XG4gIGF3YWl0IHByb2Muc3RhcnQoMCk7XG4gIHByb2Mub24oJ291dHB1dCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgIGZvciAobGV0IGxpbmUgb2YgKHN0ZG91dCB8fCBzdGRlcnIgfHwgJycpLnNwbGl0KCdcXG4nKS5maWx0ZXIoQm9vbGVhbikpIHtcbiAgICAgIGxvZy5pbmZvKGBbQVZEIE9VVFBVVF0gJHtsaW5lfWApO1xuICAgIH1cbiAgfSk7XG4gIHByb2Mub24oJ2RpZScsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICBsb2cud2FybihgRW11bGF0b3IgYXZkICR7YXZkTmFtZX0gZXhpdGVkIHdpdGggY29kZSAke2NvZGV9JHtzaWduYWwgPyBgLCBzaWduYWwgJHtzaWduYWx9YCA6ICcnfWApO1xuICB9KTtcbiAgYXdhaXQgcmV0cnkocmV0cnlUaW1lcywgYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5KGF2ZE5hbWUsIGF2ZExhdW5jaFRpbWVvdXQpKTtcbiAgYXdhaXQgdGhpcy53YWl0Rm9yRW11bGF0b3JSZWFkeShhdmRSZWFkeVRpbWVvdXQpO1xuICByZXR1cm4gcHJvYztcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQURCVmVyc2lvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZlcnNpb25TdHJpbmcgLSBBREIgdmVyc2lvbiBhcyBhIHN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7ZmxvYXR9IHZlcnNpb25GbG9hdCAtIFZlcnNpb24gbnVtYmVyIGFzIGZsb2F0IHZhbHVlICh1c2VmdWwgZm9yIGNvbXBhcmlzb24pLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1ham9yIC0gTWFqb3IgdmVyc2lvbiBudW1iZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWlub3IgLSBNaW5vciB2ZXJzaW9uIG51bWJlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYXRjaCAtIFBhdGNoIHZlcnNpb24gbnVtYmVyLlxuICovXG5cbi8qKlxuICogR2V0IHRoZSBhZGIgdmVyc2lvbi4gVGhlIHJlc3VsdCBvZiB0aGlzIG1ldGhvZCBpcyBjYWNoZWQuXG4gKlxuICogQHJldHVybiB7QURCVmVyc2lvbn0gVGhlIGN1cnJlbnQgYWRiIHZlcnNpb24uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHBhcnNlIGFkYiB2ZXJzaW9uLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRBZGJWZXJzaW9uID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uIGdldEFkYlZlcnNpb24gKCkge1xuICB0cnkge1xuICAgIGxldCBhZGJWZXJzaW9uID0gKGF3YWl0IHRoaXMuYWRiRXhlYygndmVyc2lvbicpKVxuICAgICAgLnJlcGxhY2UoL0FuZHJvaWRcXHNEZWJ1Z1xcc0JyaWRnZVxcc3ZlcnNpb25cXHMoW1xcZC5dKilbXFxzXFx3LV0qLywgJyQxJyk7XG4gICAgbGV0IHBhcnRzID0gYWRiVmVyc2lvbi5zcGxpdCgnLicpO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uU3RyaW5nOiBhZGJWZXJzaW9uLFxuICAgICAgdmVyc2lvbkZsb2F0OiBwYXJzZUZsb2F0KGFkYlZlcnNpb24pLFxuICAgICAgbWFqb3I6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICBtaW5vcjogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgIHBhdGNoOiBwYXJ0c1syXSA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBhZGIgdmVyc2lvbi4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIENoZWNrIGlmIGdpdmVuIGVtdWxhdG9yIGV4aXN0cyBpbiB0aGUgbGlzdCBvZiBhdmFpbGFibGUgYXZkcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIFRoZSBuYW1lIG9mIGVtdWxhdG9yIHRvIHZlcmlmeSBmb3IgZXhpc3RlbmNlLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbXVsYXRvciB3aXRoIGdpdmVuIG5hbWUgZG9lcyBub3QgZXhpc3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmNoZWNrQXZkRXhpc3QgPSBhc3luYyBmdW5jdGlvbiBjaGVja0F2ZEV4aXN0IChhdmROYW1lKSB7XG4gIGxldCBjbWQsIHJlc3VsdDtcbiAgdHJ5IHtcbiAgICBjbWQgPSBhd2FpdCB0aGlzLmdldFNka0JpbmFyeVBhdGgoJ2VtdWxhdG9yJyk7XG4gICAgcmVzdWx0ID0gYXdhaXQgZXhlYyhjbWQsIFsnLWxpc3QtYXZkcyddKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxldCB1bmtub3duT3B0aW9uRXJyb3IgPSBuZXcgUmVnRXhwKCd1bmtub3duIG9wdGlvbjogLWxpc3QtYXZkcycsICdpJykudGVzdChlLnN0ZGVycik7XG4gICAgaWYgKCF1bmtub3duT3B0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZXhlY3V0aW5nIGNoZWNrQXZkRXhpc3QuIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9JzsgYCArXG4gICAgICAgICAgICAgICAgICAgICAgYFN0ZGVycjogJyR7KGUuc3RkZXJyIHx8ICcnKS50cmltKCl9JzsgQ29kZTogJyR7ZS5jb2RlfSdgKTtcblxuICAgIH1cbiAgICBjb25zdCBzZGtWZXJzaW9uID0gYXdhaXQgZ2V0U2RrVG9vbHNWZXJzaW9uKCk7XG4gICAgbGV0IGJpbmFyeU5hbWUgPSAnYW5kcm9pZCc7XG4gICAgaWYgKHNka1ZlcnNpb24pIHtcbiAgICAgIGlmIChzZGtWZXJzaW9uLm1ham9yID49IDI1KSB7XG4gICAgICAgIGJpbmFyeU5hbWUgPSAnYXZkbWFuYWdlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy53YXJuKGBEZWZhdWx0aW5nIGJpbmFyeSBuYW1lIHRvICcke2JpbmFyeU5hbWV9JywgYmVjYXVzZSBTREsgdmVyc2lvbiBjYW5ub3QgYmUgcGFyc2VkYCk7XG4gICAgfVxuICAgIC8vIElmIC1saXN0LWF2ZHMgb3B0aW9uIGlzIG5vdCBhdmFpbGFibGUsIHVzZSBhbmRyb2lkIGNvbW1hbmQgYXMgYW4gYWx0ZXJuYXRpdmVcbiAgICBjbWQgPSBhd2FpdCB0aGlzLmdldFNka0JpbmFyeVBhdGgoYmluYXJ5TmFtZSk7XG4gICAgcmVzdWx0ID0gYXdhaXQgZXhlYyhjbWQsIFsnbGlzdCcsICdhdmQnLCAnLWMnXSk7XG4gIH1cbiAgaWYgKHJlc3VsdC5zdGRvdXQuaW5kZXhPZihhdmROYW1lKSA9PT0gLTEpIHtcbiAgICBsZXQgZXhpc3RpbmdzID0gYCgke3Jlc3VsdC5zdGRvdXQudHJpbSgpLnJlcGxhY2UoL1tcXG5dL2csICcpLCAoJyl9KWA7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBdmQgJyR7YXZkTmFtZX0nIGlzIG5vdCBhdmFpbGFibGUuIHBsZWFzZSBzZWxlY3QgeW91ciBhdmQgbmFtZSBmcm9tIG9uZSBvZiB0aGVzZTogJyR7ZXhpc3RpbmdzfSdgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgY3VycmVudCBlbXVsYXRvciBpcyByZWFkeSB0byBhY2NlcHQgZnVydGhlciBjb21tYW5kcyAoYm9vdGluZyBjb21wbGV0ZWQpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0TXMgWzIwMDAwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZW11bGF0b3IgaXMgbm90IHJlYWR5IHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMud2FpdEZvckVtdWxhdG9yUmVhZHkgPSBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yRW11bGF0b3JSZWFkeSAodGltZW91dE1zID0gMjAwMDApIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuc2hlbGwoWydnZXRwcm9wJywgJ2luaXQuc3ZjLmJvb3RhbmltJ10pKS5pbmNsdWRlcygnc3RvcHBlZCcpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgcGFja2FnZSBtYW5hZ2VyIHNlcnZpY2UgbWlnaHQgc3RpbGwgYmVpbmcgaW5pdGlhbGl6ZWRcbiAgICAgICAgLy8gb24gc2xvdyBzeXN0ZW1zIGV2ZW4gYWZ0ZXIgZW11bGF0b3IgYm9vdGluZyBpcyBjb21wbGV0ZWQuXG4gICAgICAgIC8vIFRoZSB1c3VhbCBvdXRwdXQgb2YgYHBtIGdldC1pbnN0YWxsLWxvY2F0aW9uYCBjb21tYW5kIGxvb2tzIGxpa2UgYDBbYXV0b11gXG4gICAgICAgIHJldHVybiAvXFxkK1xcW1xcdytcXF0vLnRlc3QoYXdhaXQgdGhpcy5zaGVsbChbJ3BtJywgJ2dldC1pbnN0YWxsLWxvY2F0aW9uJ10pKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cuZGVidWcoYFdhaXRpbmcgZm9yIGVtdWxhdG9yIHN0YXJ0dXAuIEludGVybWVkaWF0ZSBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHdhaXRNczogdGltZW91dE1zLFxuICAgICAgaW50ZXJ2YWxNczogMzAwMCxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRW11bGF0b3IgaXMgbm90IHJlYWR5IHdpdGhpbiAke3RpbWVvdXRNc31tc2ApO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGRldmljZSBpcyByZWFkeSB0byBhY2NlcHQgZnVydGhlciBjb21tYW5kcyAoYm9vdGluZyBjb21wbGV0ZWQpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcHBEZXZpY2VSZWFkeVRpbWVvdXQgWzMwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzZWNvbmRzIHRvIHdhaXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRldmljZSBpcyBub3QgcmVhZHkgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy53YWl0Rm9yRGV2aWNlID0gYXN5bmMgZnVuY3Rpb24gd2FpdEZvckRldmljZSAoYXBwRGV2aWNlUmVhZHlUaW1lb3V0ID0gMzApIHtcbiAgdGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQgPSBhcHBEZXZpY2VSZWFkeVRpbWVvdXQ7XG4gIGNvbnN0IHJldHJpZXMgPSAzO1xuICBjb25zdCB0aW1lb3V0ID0gcGFyc2VJbnQodGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQsIDEwKSAvIHJldHJpZXMgKiAxMDAwO1xuICBhd2FpdCByZXRyeShyZXRyaWVzLCBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYWRiRXhlYygnd2FpdC1mb3ItZGV2aWNlJywge3RpbWVvdXR9KTtcbiAgICAgIGF3YWl0IHRoaXMucGluZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdhaXRpbmcgZm9yIHRoZSBkZXZpY2UgdG8gYmUgYXZhaWxhYmxlLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSdgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWJvb3QgdGhlIGN1cnJlbnQgZGV2aWNlIGFuZCB3YWl0IHVudGlsIGl0IGlzIGNvbXBsZXRlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cmllcyBbREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVNdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlYm9vdCByZXRyaWVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZXZpY2UgZmFpbGVkIHRvIHJlYm9vdCBhbmQgbnVtYmVyIG9mIHJldHJpZXMgaXMgZXhjZWVkZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlYm9vdCA9IGFzeW5jIGZ1bmN0aW9uIHJlYm9vdCAocmV0cmllcyA9IERFRkFVTFRfQURCX1JFQk9PVF9SRVRSSUVTKSB7XG4gIGF3YWl0IHRoaXMuc2hlbGwoWydzdG9wJ10sIHtcbiAgICBwcml2aWxlZ2VkOiB0cnVlLFxuICB9KTtcbiAgYXdhaXQgQi5kZWxheSgyMDAwKTsgLy8gbGV0IHRoZSBlbXUgZmluaXNoIHN0b3BwaW5nO1xuICBhd2FpdCB0aGlzLnNldERldmljZVByb3BlcnR5KCdzeXMuYm9vdF9jb21wbGV0ZWQnLCAwKTtcbiAgYXdhaXQgdGhpcy5zaGVsbChbJ3N0YXJ0J10sIHtcbiAgICBwcml2aWxlZ2VkOiB0cnVlLFxuICB9KTtcbiAgY29uc3Qgc3RhcnRlZCA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gIGF3YWl0IHJldHJ5SW50ZXJ2YWwocmV0cmllcywgMTAwMCwgYXN5bmMgKCkgPT4ge1xuICAgIGlmICgoYXdhaXQgdGhpcy5nZXREZXZpY2VQcm9wZXJ0eSgnc3lzLmJvb3RfY29tcGxldGVkJykpID09PSAnMScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgc3RhY2sgdHJhY2UsIHNvIG5vIGxvZy5lcnJvckFuZFRocm93XG4gICAgY29uc3QgbXNnID0gYFJlYm9vdCBpcyBub3QgY29tcGxldGVkIGFmdGVyICR7cHJvY2Vzcy5ocnRpbWUoc3RhcnRlZClbMF19c2A7XG4gICAgbG9nLmRlYnVnKG1zZyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTd2l0Y2ggYWRiIHNlcnZlciB0byByb290IG1vZGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBvZiB0aGUgc3dpdGNoIHdhcyBzdWNjZXNzZnVsIG9yIGZhbHNlXG4gKiAgICAgICAgICAgICAgICAgICBpZiB0aGUgc3dpdGNoIGZhaWxlZC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMucm9vdCA9IGFzeW5jIGZ1bmN0aW9uIHJvb3QgKCkge1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIFsncm9vdCddKTtcblxuICAgIC8vIG9uIHJlYWwgZGV2aWNlcyBpbiBzb21lIHNpdHVhdGlvbnMgd2UgZ2V0IGFuIGVycm9yIGluIHRoZSBzdGRvdXRcbiAgICBpZiAoc3Rkb3V0ICYmIHN0ZG91dC5pbmRleE9mKCdhZGJkIGNhbm5vdCBydW4gYXMgcm9vdCcpICE9PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHN0ZG91dC50cmltKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgVW5hYmxlIHRvIHJvb3QgYWRiIGRhZW1vbjogJyR7ZXJyLm1lc3NhZ2V9Jy4gQ29udGludWluZ2ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTd2l0Y2ggYWRiIHNlcnZlciB0byBub24tcm9vdCBtb2RlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgb2YgdGhlIHN3aXRjaCB3YXMgc3VjY2Vzc2Z1bCBvciBmYWxzZVxuICogICAgICAgICAgICAgICAgICAgaWYgdGhlIHN3aXRjaCBmYWlsZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnVucm9vdCA9IGFzeW5jIGZ1bmN0aW9uIHVucm9vdCAoKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgWyd1bnJvb3QnXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy53YXJuKGBVbmFibGUgdG8gdW5yb290IGFkYiBkYWVtb246ICcke2Vyci5tZXNzYWdlfScuIENvbnRpbnVpbmdgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXNlciBpcyByb290XG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdXNlciBpcyByb290XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGlkZW50aWZ5aW5nXG4gKiB0aGUgdXNlci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuaXNSb290ID0gYXN5bmMgZnVuY3Rpb24gaXNSb290ICgpIHtcbiAgcmV0dXJuIChhd2FpdCB0aGlzLnNoZWxsKFsnd2hvYW1pJ10pKS50cmltKCkgPT09ICdyb290Jztcbn07XG5cbi8qKlxuICogVmVyaWZ5IHdoZXRoZXIgYSByZW1vdGUgcGF0aCBleGlzdHMgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIHRvIHZlcmlmeS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdpdmVuIHBhdGggZXhpc3RzIG9uIHRoZSBkZXZpY2UuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmZpbGVFeGlzdHMgPSBhc3luYyBmdW5jdGlvbiBmaWxlRXhpc3RzIChyZW1vdGVQYXRoKSB7XG4gIGxldCBmaWxlcyA9IGF3YWl0IHRoaXMubHMocmVtb3RlUGF0aCk7XG4gIHJldHVybiBmaWxlcy5sZW5ndGggPiAwO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG91dHB1dCBvZiBfbHNfIGNvbW1hbmQgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoICh0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIF9sc18gY29tbWFuZCkuXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBvcHRzIFtbXV0gLSBBZGRpdGlvbmFsIF9sc18gb3B0aW9ucy5cbiAqIEByZXR1cm4ge0FycmF5LjxTdHJpbmc+fSBUaGUgX2xzXyBvdXRwdXQgYXMgYW4gYXJyYXkgb2Ygc3BsaXQgbGluZXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQgb2YgdGhlIGdpdmVuIF9yZW1vdGVQYXRoX1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIGRvZXMgbm90IGV4aXN0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5scyA9IGFzeW5jIGZ1bmN0aW9uIGxzIChyZW1vdGVQYXRoLCBvcHRzID0gW10pIHtcbiAgdHJ5IHtcbiAgICBsZXQgYXJncyA9IFsnbHMnLCAuLi5vcHRzLCByZW1vdGVQYXRoXTtcbiAgICBsZXQgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChhcmdzKTtcbiAgICBsZXQgbGluZXMgPSBzdGRvdXQuc3BsaXQoJ1xcbicpO1xuICAgIHJldHVybiBsaW5lcy5tYXAoKGwpID0+IGwudHJpbSgpKVxuICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgLmZpbHRlcigobCkgPT4gbC5pbmRleE9mKCdObyBzdWNoIGZpbGUnKSA9PT0gLTEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZignTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScpID09PSAtMSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSBwYXJ0aWN1bGFyIGZpbGUgbG9jYXRlZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggdG8gdGhlIGZpbGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEZpbGUgc2l6ZSBpbiBieXRlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGUgc2l6ZSBvZiB0aGUgZ2l2ZW4gZmlsZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZmlsZVNpemUgPSBhc3luYyBmdW5jdGlvbiBmaWxlU2l6ZSAocmVtb3RlUGF0aCkge1xuICB0cnkge1xuICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgdGhpcy5scyhyZW1vdGVQYXRoLCBbJy1sYSddKTtcbiAgICBpZiAoZmlsZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlbW90ZSBwYXRoIGlzIG5vdCBhIGZpbGVgKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20vci9mT3M0UDQvOFxuICAgIGNvbnN0IG1hdGNoID0gL1tyd3hzU3RUXFwtK117MTB9W1xcc1xcZF0qXFxzW15cXHNdK1xccytbXlxcc10rXFxzKyhcXGQrKS8uZXhlYyhmaWxlc1swXSk7XG4gICAgaWYgKCFtYXRjaCB8fCBfLmlzTmFOKHBhcnNlSW50KG1hdGNoWzFdLCAxMCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBzaXplIGZyb20gbGlzdCBvdXRwdXQ6ICcke2ZpbGVzWzBdfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGdldCBmaWxlIHNpemUgZm9yICcke3JlbW90ZVBhdGh9JzogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbnN0YWxscyB0aGUgZ2l2ZW4gY2VydGlmaWNhdGUgb24gYSByb290ZWQgcmVhbCBkZXZpY2Ugb3JcbiAqIGFuIGVtdWxhdG9yLiBUaGUgZW11bGF0b3IgbXVzdCBiZSBleGVjdXRlZCB3aXRoIGAtd3JpdGFibGUtc3lzdGVtYFxuICogY29tbWFuZCBsaW5lIG9wdGlvbiBhbmQgYWRiIGRhZW1vbiBzaG91bGQgYmUgcnVubmluZyBpbiByb290XG4gKiBtb2RlIGZvciB0aGlzIG1ldGhvZCB0byB3b3JrIHByb3Blcmx5LiBUaGUgbWV0aG9kIGFsc28gcmVxdWlyZXNcbiAqIG9wZW5zc2wgdG9vbCB0byBiZSBhdmFpbGFibGUgb24gdGhlIGRlc3RpbmF0aW9uIHN5c3RlbS5cbiAqIFJlYWQgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9hcHBpdW0vaXNzdWVzLzEwOTY0XG4gKiBmb3IgbW9yZSBkZXRhaWxzIG9uIHRoaXMgdG9waWNcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGNlcnQgLSBiYXNlNjQtZGVjb2RlZCBjb250ZW50IG9mIHRoZSBhY3R1YWwgY2VydGlmaWNhdGVcbiAqIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9yIGEgYnVmZmVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgb3BlbnNzbCB0b29sIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIGRlc3RpbmF0aW9uIHN5c3RlbVxuICogb3IgaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGluc3RhbGxpbmcgdGhlIGNlcnRpZmljYXRlXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmluc3RhbGxNaXRtQ2VydGlmaWNhdGUgPSBhc3luYyBmdW5jdGlvbiBpbnN0YWxsTWl0bUNlcnRpZmljYXRlIChjZXJ0KSB7XG4gIGNvbnN0IG9wZW5Tc2wgPSBhd2FpdCBnZXRPcGVuU3NsRm9yT3MoKTtcblxuICBpZiAoIV8uaXNCdWZmZXIoY2VydCkpIHtcbiAgICBjZXJ0ID0gQnVmZmVyLmZyb20oY2VydCwgJ2Jhc2U2NCcpO1xuICB9XG5cbiAgY29uc3QgdG1wUm9vdCA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICB0cnkge1xuICAgIGNvbnN0IHNyY0NlcnQgPSBwYXRoLnJlc29sdmUodG1wUm9vdCwgJ3NvdXJjZS5jZXInKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoc3JjQ2VydCwgY2VydCk7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLCAnLW5vb3V0JywgJy1oYXNoJywgJy1pbicsIHNyY0NlcnRdKTtcbiAgICBjb25zdCBjZXJ0SGFzaCA9IHN0ZG91dC50cmltKCk7XG4gICAgbG9nLmRlYnVnKGBHb3QgY2VydGlmaWNhdGUgaGFzaDogJHtjZXJ0SGFzaH1gKTtcbiAgICBsb2cuZGVidWcoJ1ByZXBhcmluZyBjZXJ0aWZpY2F0ZSBjb250ZW50Jyk7XG4gICAgKHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLCAnLWluJywgc3JjQ2VydF0sIHtpc0J1ZmZlcjogdHJ1ZX0pKTtcbiAgICBsZXQgZHN0Q2VydENvbnRlbnQgPSBzdGRvdXQ7XG4gICAgKHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLFxuICAgICAgJy1pbicsIHNyY0NlcnQsXG4gICAgICAnLXRleHQnLFxuICAgICAgJy1maW5nZXJwcmludCcsXG4gICAgICAnLW5vb3V0J10sIHtpc0J1ZmZlcjogdHJ1ZX0pKTtcbiAgICBkc3RDZXJ0Q29udGVudCA9IEJ1ZmZlci5jb25jYXQoW2RzdENlcnRDb250ZW50LCBzdGRvdXRdKTtcbiAgICBjb25zdCBkc3RDZXJ0ID0gcGF0aC5yZXNvbHZlKHRtcFJvb3QsIGAke2NlcnRIYXNofS4wYCk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGRzdENlcnQsIGRzdENlcnRDb250ZW50KTtcbiAgICBsb2cuZGVidWcoJ1JlbW91bnRpbmcgL3N5c3RlbSBpbiBydyBtb2RlJyk7XG4gICAgLy8gU29tZXRpbWVzIGVtdWxhdG9yIHJlYm9vdCBpcyBzdGlsbCBub3QgZnVsbHkgZmluaXNoZWQgb24gdGhpcyBzdGFnZSwgc28gcmV0cnlcbiAgICBhd2FpdCByZXRyeUludGVydmFsKDUsIDIwMDAsIGFzeW5jICgpID0+IGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3JlbW91bnQnXSkpO1xuICAgIGxvZy5kZWJ1ZyhgVXBsb2FkaW5nIHRoZSBnZW5lcmF0ZWQgY2VydGlmaWNhdGUgZnJvbSAnJHtkc3RDZXJ0fScgdG8gJyR7Q0VSVFNfUk9PVH0nYCk7XG4gICAgYXdhaXQgdGhpcy5wdXNoKGRzdENlcnQsIENFUlRTX1JPT1QpO1xuICAgIGxvZy5kZWJ1ZygnUmVtb3VudGluZyAvc3lzdGVtIHRvIGNvbmZpcm0gY2hhbmdlcycpO1xuICAgIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3JlbW91bnQnXSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGluamVjdCB0aGUgY3VzdG9tIGNlcnRpZmljYXRlLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYElzIHRoZSBjZXJ0aWZpY2F0ZSBwcm9wZXJseSBlbmNvZGVkIGludG8gYmFzZTY0LXN0cmluZz8gYCArXG4gICAgICAgICAgICAgICAgICAgIGBEbyB5b3UgaGF2ZSByb290IHBlcm1pc3Npb25zIG9uIHRoZSBkZXZpY2U/IGAgK1xuICAgICAgICAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKHRtcFJvb3QpO1xuICB9XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIGlmIHRoZSBnaXZlbiByb290IGNlcnRpZmljYXRlIGlzIGFscmVhZHkgaW5zdGFsbGVkIG9uIHRoZSBkZXZpY2UuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBjZXJ0IC0gYmFzZTY0LWRlY29kZWQgY29udGVudCBvZiB0aGUgYWN0dWFsIGNlcnRpZmljYXRlXG4gKiByZXByZXNlbnRlZCBhcyBhIHN0cmluZyBvciBhIGJ1ZmZlclxuICogQHRocm93cyB7RXJyb3J9IElmIG9wZW5zc2wgdG9vbCBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBkZXN0aW5hdGlvbiBzeXN0ZW1cbiAqIG9yIGlmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBjaGVja2luZyB0aGUgY2VydGlmaWNhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBnaXZlbiBjZXJ0aWZpY2F0ZSBpcyBhbHJlYWR5IGluc3RhbGxlZFxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5pc01pdG1DZXJ0aWZpY2F0ZUluc3RhbGxlZCA9IGFzeW5jIGZ1bmN0aW9uIGlzTWl0bUNlcnRpZmljYXRlSW5zdGFsbGVkIChjZXJ0KSB7XG4gIGNvbnN0IG9wZW5Tc2wgPSBhd2FpdCBnZXRPcGVuU3NsRm9yT3MoKTtcblxuICBpZiAoIV8uaXNCdWZmZXIoY2VydCkpIHtcbiAgICBjZXJ0ID0gQnVmZmVyLmZyb20oY2VydCwgJ2Jhc2U2NCcpO1xuICB9XG5cbiAgY29uc3QgdG1wUm9vdCA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICBsZXQgY2VydEhhc2g7XG4gIHRyeSB7XG4gICAgY29uc3QgdG1wQ2VydCA9IHBhdGgucmVzb2x2ZSh0bXBSb290LCAnc291cmNlLmNlcicpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZSh0bXBDZXJ0LCBjZXJ0KTtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JywgJy1ub291dCcsICctaGFzaCcsICctaW4nLCB0bXBDZXJ0XSk7XG4gICAgY2VydEhhc2ggPSBzdGRvdXQudHJpbSgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXRyaWV2ZSB0aGUgY2VydGlmaWNhdGUgaGFzaC4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBJcyB0aGUgY2VydGlmaWNhdGUgcHJvcGVybHkgZW5jb2RlZCBpbnRvIGJhc2U2NC1zdHJpbmc/IGAgK1xuICAgICAgICAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKHRtcFJvb3QpO1xuICB9XG4gIGNvbnN0IGRzdFBhdGggPSBwYXRoLnBvc2l4LnJlc29sdmUoQ0VSVFNfUk9PVCwgYCR7Y2VydEhhc2h9LjBgKTtcbiAgbG9nLmRlYnVnKGBDaGVja2luZyBpZiB0aGUgY2VydGlmaWNhdGUgaXMgYWxyZWFkeSBpbnN0YWxsZWQgYXQgJyR7ZHN0UGF0aH0nYCk7XG4gIHJldHVybiBhd2FpdCB0aGlzLmZpbGVFeGlzdHMoZHN0UGF0aCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzeXN0ZW1DYWxsTWV0aG9kcztcbmV4cG9ydCB7IERFRkFVTFRfQURCX0VYRUNfVElNRU9VVCB9O1xuIl0sImZpbGUiOiJsaWIvdG9vbHMvc3lzdGVtLWNhbGxzLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
